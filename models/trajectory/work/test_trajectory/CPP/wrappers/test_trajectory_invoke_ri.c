/* Body file for function test_Trajectory
 * Generated by TASTE on 2021-06-09 12:19:50
 * You can edit this file, it will not be overwritten
 * Provided interfaces : trigger
 * Required interfaces : updateMotionCommand, updatePose, updateTrajectory, updateWaypoint
 * User-defined properties for this function:
 *   |_ Taste::Active_Interfaces = enabled
 *   |_ Taste::coordinates = 185 149 503 368
 * Timers              : 
 */
#include <stdlib.h>
#ifdef __unix__
   #include <stdio.h>
   #include "PrintTypesAsASN1.h"
   #include "timeInMS.h"
#endif
#include "C_ASN1_Types.h"
#include "dataview-uniq.h"

// reference to flag preventing calls to RIs during the startup transition
extern unsigned test_trajectory_initialized;
// in case that happens, use system's abort function to crash the application
extern void abort (void);

void test_trajectory_RI_updateMotionCommand
      (const asn1SccBase_commands_Motion2D *IN_command)

{
   // Check that we are not in the startup transition
   if (2 != test_trajectory_initialized) {
      #ifdef __unix__
         puts("A call to test_trajectory_RI_updateMotionCommand was made during system startup.");
         puts("This is not allowed because the system is not yet fully initialized. Please fix your code/models");
      #endif
      // crash the application
      abort();
   }

   #ifdef __unix__
      // Log MSC data on Linux when environment variable is set
      static int innerMsc = -1;
      if (-1 == innerMsc)
         innerMsc = (NULL != getenv("TASTE_INNER_MSC"))?1:0;
      if (1 == innerMsc) {
         long long msc_time = getTimeInMilliseconds();
         PrintASN1Base_commands_Motion2D ("INNERDATA: updatemotioncommand::Base_commands_Motion2D::command", IN_command);
         puts(""); // add newline
         // Log message to vizkit3d_MotionCommand (corresponding PI: updateMotionCommand)
         printf ("INNER: test_trajectory,vizkit3d_motioncommand,updatemotioncommand,%lld\n", msc_time);
         fflush(stdout);
      }
   #endif
   // Encode parameter command
   static asn1SccBase_commands_Motion2D IN_buf_command;
   int size_IN_buf_command =
      Encode_NATIVE_Base_commands_Motion2D
        ((void *)&IN_buf_command,
          sizeof(asn1SccBase_commands_Motion2D),
          (asn1SccBase_commands_Motion2D *)IN_command);
   if (-1 == size_IN_buf_command) {
      #ifdef __unix__
         puts ("[ERROR] ASN.1 Encoding failed in test_trajectory_RI_updateMotionCommand, parameter command");
      #endif
        /* Crash the application due to message loss */
        abort();
   }


   // Call Middleware interface
   extern void vm_test_trajectory_updatemotioncommand
     (void *, size_t);

   vm_test_trajectory_updatemotioncommand
     ((void *)&IN_buf_command, (size_t)size_IN_buf_command);


}void test_trajectory_RI_updatePose
      (const asn1SccBase_Pose *IN_pose)

{
   // Check that we are not in the startup transition
   if (2 != test_trajectory_initialized) {
      #ifdef __unix__
         puts("A call to test_trajectory_RI_updatePose was made during system startup.");
         puts("This is not allowed because the system is not yet fully initialized. Please fix your code/models");
      #endif
      // crash the application
      abort();
   }

   #ifdef __unix__
      // Log MSC data on Linux when environment variable is set
      static int innerMsc = -1;
      if (-1 == innerMsc)
         innerMsc = (NULL != getenv("TASTE_INNER_MSC"))?1:0;
      if (1 == innerMsc) {
         long long msc_time = getTimeInMilliseconds();
         PrintASN1Base_Pose ("INNERDATA: updatepose::Base_Pose::pose", IN_pose);
         puts(""); // add newline
         // Log message to vizkit3d_MotionCommand (corresponding PI: updatePose)
         printf ("INNER: test_trajectory,vizkit3d_motioncommand,updatepose,%lld\n", msc_time);
         fflush(stdout);
      }
   #endif
   // Encode parameter pose
   static asn1SccBase_Pose IN_buf_pose;
   int size_IN_buf_pose =
      Encode_NATIVE_Base_Pose
        ((void *)&IN_buf_pose,
          sizeof(asn1SccBase_Pose),
          (asn1SccBase_Pose *)IN_pose);
   if (-1 == size_IN_buf_pose) {
      #ifdef __unix__
         puts ("[ERROR] ASN.1 Encoding failed in test_trajectory_RI_updatePose, parameter pose");
      #endif
        /* Crash the application due to message loss */
        abort();
   }


   // Call Middleware interface
   extern void vm_test_trajectory_updatepose
     (void *, size_t);

   vm_test_trajectory_updatepose
     ((void *)&IN_buf_pose, (size_t)size_IN_buf_pose);


}void test_trajectory_RI_updateTrajectory
      (const asn1SccWrappers_Vector3d *IN_point)

{
   // Check that we are not in the startup transition
   if (2 != test_trajectory_initialized) {
      #ifdef __unix__
         puts("A call to test_trajectory_RI_updateTrajectory was made during system startup.");
         puts("This is not allowed because the system is not yet fully initialized. Please fix your code/models");
      #endif
      // crash the application
      abort();
   }

   #ifdef __unix__
      // Log MSC data on Linux when environment variable is set
      static int innerMsc = -1;
      if (-1 == innerMsc)
         innerMsc = (NULL != getenv("TASTE_INNER_MSC"))?1:0;
      if (1 == innerMsc) {
         long long msc_time = getTimeInMilliseconds();
         PrintASN1Wrappers_Vector3d ("INNERDATA: updatetrajectory::Wrappers_Vector3d::point", IN_point);
         puts(""); // add newline
         // Log message to vizkit3d_Trajectory (corresponding PI: updateTrajectory)
         printf ("INNER: test_trajectory,vizkit3d_trajectory,updatetrajectory,%lld\n", msc_time);
         fflush(stdout);
      }
   #endif
   // Encode parameter point
   static asn1SccWrappers_Vector3d IN_buf_point;
   int size_IN_buf_point =
      Encode_NATIVE_Wrappers_Vector3d
        ((void *)&IN_buf_point,
          sizeof(asn1SccWrappers_Vector3d),
          (asn1SccWrappers_Vector3d *)IN_point);
   if (-1 == size_IN_buf_point) {
      #ifdef __unix__
         puts ("[ERROR] ASN.1 Encoding failed in test_trajectory_RI_updateTrajectory, parameter point");
      #endif
        /* Crash the application due to message loss */
        abort();
   }


   // Call Middleware interface
   extern void vm_test_trajectory_updatetrajectory
     (void *, size_t);

   vm_test_trajectory_updatetrajectory
     ((void *)&IN_buf_point, (size_t)size_IN_buf_point);


}void test_trajectory_RI_updateWaypoint
      (const asn1SccBase_Waypoint *IN_waypoint)

{
   // Check that we are not in the startup transition
   if (2 != test_trajectory_initialized) {
      #ifdef __unix__
         puts("A call to test_trajectory_RI_updateWaypoint was made during system startup.");
         puts("This is not allowed because the system is not yet fully initialized. Please fix your code/models");
      #endif
      // crash the application
      abort();
   }

   #ifdef __unix__
      // Log MSC data on Linux when environment variable is set
      static int innerMsc = -1;
      if (-1 == innerMsc)
         innerMsc = (NULL != getenv("TASTE_INNER_MSC"))?1:0;
      if (1 == innerMsc) {
         long long msc_time = getTimeInMilliseconds();
         PrintASN1Base_Waypoint ("INNERDATA: updatewaypoint::Base_Waypoint::waypoint", IN_waypoint);
         puts(""); // add newline
         // Log message to vizkit3d_Waypoint (corresponding PI: updateWaypoint)
         printf ("INNER: test_trajectory,vizkit3d_waypoint,updatewaypoint,%lld\n", msc_time);
         fflush(stdout);
      }
   #endif
   // Encode parameter waypoint
   static asn1SccBase_Waypoint IN_buf_waypoint;
   int size_IN_buf_waypoint =
      Encode_NATIVE_Base_Waypoint
        ((void *)&IN_buf_waypoint,
          sizeof(asn1SccBase_Waypoint),
          (asn1SccBase_Waypoint *)IN_waypoint);
   if (-1 == size_IN_buf_waypoint) {
      #ifdef __unix__
         puts ("[ERROR] ASN.1 Encoding failed in test_trajectory_RI_updateWaypoint, parameter waypoint");
      #endif
        /* Crash the application due to message loss */
        abort();
   }


   // Call Middleware interface
   extern void vm_test_trajectory_updatewaypoint
     (void *, size_t);

   vm_test_trajectory_updatewaypoint
     ((void *)&IN_buf_waypoint, (size_t)size_IN_buf_waypoint);


}

