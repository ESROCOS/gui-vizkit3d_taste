#ifndef GENERATED_ASN1SCC_DATAVIEW_UNIQ_H
#define GENERATED_ASN1SCC_DATAVIEW_UNIQ_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif



typedef enum {
    asn1Sccacceleration = 0,
    asn1Scceffort = 1,
    asn1Sccposition = 2,
    asn1Sccraw = 3,
    asn1Sccspeed = 4,
    asn1Sccunset = 5
} asn1SccBase_JointState_MODE;

#define asn1SccBase_JointState_MODE_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_JointState_MODE_REQUIRED_BITS_FOR_ENCODING        3
#define asn1SccBase_JointState_MODE_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_JointState_MODE_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define asn1SccBase_JointState_MODE_REQUIRED_BYTES_FOR_XER_ENCODING   58

void asn1SccBase_JointState_MODE_Initialize(asn1SccBase_JointState_MODE* pVal);
flag asn1SccBase_JointState_MODE_IsConstraintValid(const asn1SccBase_JointState_MODE* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointState_MODE_unknown_enumeration_value 
#define ERR_asn1SccBase_JointState_MODE_unknown_enumeration_value		1002  /**/
#endif
#ifndef ERR_asn1SccBase_JointState_MODE 
#define ERR_asn1SccBase_JointState_MODE		1001  /**/
#endif

typedef enum {
    asn1Sccmicroseconds = 0,
    asn1Sccmilliseconds = 1,
    asn1Sccseconds = 2
} asn1SccBase_Time_Resolution;

#define asn1SccBase_Time_Resolution_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_Time_Resolution_REQUIRED_BITS_FOR_ENCODING        2
#define asn1SccBase_Time_Resolution_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_Time_Resolution_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define asn1SccBase_Time_Resolution_REQUIRED_BYTES_FOR_XER_ENCODING   62

void asn1SccBase_Time_Resolution_Initialize(asn1SccBase_Time_Resolution* pVal);
flag asn1SccBase_Time_Resolution_IsConstraintValid(const asn1SccBase_Time_Resolution* val, int* pErrCode);
#ifndef ERR_asn1SccBase_Time_Resolution_unknown_enumeration_value 
#define ERR_asn1SccBase_Time_Resolution_unknown_enumeration_value		1004  /**/
#endif
#ifndef ERR_asn1SccBase_Time_Resolution 
#define ERR_asn1SccBase_Time_Resolution		1003  /**/
#endif

typedef enum {
    asn1Sccderivative_to_next = 0,
    asn1Sccderivative_to_prior = 1,
    asn1Sccknuckle_point = 2,
    asn1Sccordinary_point = 3,
    asn1Sccsecond_derivative_to_next = 4,
    asn1Sccsecond_derivative_to_prior = 5,
    asn1Scctangent_point_for_next = 6,
    asn1Scctangent_point_for_prior = 7
} asn1SccBase_geometry_SplineBase_CoordinateType;

#define asn1SccBase_geometry_SplineBase_CoordinateType_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_geometry_SplineBase_CoordinateType_REQUIRED_BITS_FOR_ENCODING        3
#define asn1SccBase_geometry_SplineBase_CoordinateType_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_geometry_SplineBase_CoordinateType_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define asn1SccBase_geometry_SplineBase_CoordinateType_REQUIRED_BYTES_FOR_XER_ENCODING   132

void asn1SccBase_geometry_SplineBase_CoordinateType_Initialize(asn1SccBase_geometry_SplineBase_CoordinateType* pVal);
flag asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(const asn1SccBase_geometry_SplineBase_CoordinateType* val, int* pErrCode);
#ifndef ERR_asn1SccBase_geometry_SplineBase_CoordinateType_unknown_enumeration_value 
#define ERR_asn1SccBase_geometry_SplineBase_CoordinateType_unknown_enumeration_value		1006  /**/
#endif
#ifndef ERR_asn1SccBase_geometry_SplineBase_CoordinateType 
#define ERR_asn1SccBase_geometry_SplineBase_CoordinateType		1005  /**/
#endif

typedef enum {
    asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_measurement_error = 0,
    asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_far = 1,
    asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_near = 2,
    asn1Sccvalid_measurement = 3
} asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE;

#define asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BITS_FOR_ENCODING        2
#define asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BYTES_FOR_XER_ENCODING   132

void asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal);
flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_unknown_enumeration_value 
#define ERR_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_unknown_enumeration_value		1008  /**/
#endif
#ifndef ERR_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE 
#define ERR_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE		1007  /**/
#endif

typedef enum {
    asn1Sccplanar = 0,
    asn1Sccpolar = 1
} asn1SccBase_samples_DepthMap_PROJECTION_TYPE;

#define asn1SccBase_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BITS_FOR_ENCODING        1
#define asn1SccBase_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BITS_FOR_ACN_ENCODING    1
#define asn1SccBase_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BYTES_FOR_XER_ENCODING   92

void asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Initialize(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal);
flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_PROJECTION_TYPE_unknown_enumeration_value 
#define ERR_asn1SccBase_samples_DepthMap_PROJECTION_TYPE_unknown_enumeration_value		1010  /**/
#endif
#ifndef ERR_asn1SccBase_samples_DepthMap_PROJECTION_TYPE 
#define ERR_asn1SccBase_samples_DepthMap_PROJECTION_TYPE		1009  /**/
#endif

typedef enum {
    asn1Sccunit_x = 0,
    asn1Sccunit_y = 1,
    asn1Sccunit_z = 2
} asn1SccBase_samples_DepthMap_UNIT_AXIS;

#define asn1SccBase_samples_DepthMap_UNIT_AXIS_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_samples_DepthMap_UNIT_AXIS_REQUIRED_BITS_FOR_ENCODING        2
#define asn1SccBase_samples_DepthMap_UNIT_AXIS_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_samples_DepthMap_UNIT_AXIS_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define asn1SccBase_samples_DepthMap_UNIT_AXIS_REQUIRED_BYTES_FOR_XER_ENCODING   82

void asn1SccBase_samples_DepthMap_UNIT_AXIS_Initialize(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal);
flag asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const asn1SccBase_samples_DepthMap_UNIT_AXIS* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_UNIT_AXIS_unknown_enumeration_value 
#define ERR_asn1SccBase_samples_DepthMap_UNIT_AXIS_unknown_enumeration_value		1012  /**/
#endif
#ifndef ERR_asn1SccBase_samples_DepthMap_UNIT_AXIS 
#define ERR_asn1SccBase_samples_DepthMap_UNIT_AXIS		1011  /**/
#endif

typedef enum {
    asn1Sccend_laser_range_errors = 0,
    asn1Sccmax_range_error = 1,
    asn1SccBase_samples_LASER_RANGE_ERRORS_measurement_error = 2,
    asn1Sccother_range_errors = 3,
    asn1SccBase_samples_LASER_RANGE_ERRORS_too_far = 4,
    asn1SccBase_samples_LASER_RANGE_ERRORS_too_near = 5
} asn1SccBase_samples_LASER_RANGE_ERRORS;

#define asn1SccBase_samples_LASER_RANGE_ERRORS_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_samples_LASER_RANGE_ERRORS_REQUIRED_BITS_FOR_ENCODING        3
#define asn1SccBase_samples_LASER_RANGE_ERRORS_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_samples_LASER_RANGE_ERRORS_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define asn1SccBase_samples_LASER_RANGE_ERRORS_REQUIRED_BYTES_FOR_XER_ENCODING   86

void asn1SccBase_samples_LASER_RANGE_ERRORS_Initialize(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal);
flag asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(const asn1SccBase_samples_LASER_RANGE_ERRORS* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_LASER_RANGE_ERRORS_unknown_enumeration_value 
#define ERR_asn1SccBase_samples_LASER_RANGE_ERRORS_unknown_enumeration_value		1014  /**/
#endif
#ifndef ERR_asn1SccBase_samples_LASER_RANGE_ERRORS 
#define ERR_asn1SccBase_samples_LASER_RANGE_ERRORS		1013  /**/
#endif

typedef enum {
    asn1Scccompressed_modes = 0,
    asn1Sccmode_bayer = 1,
    asn1Sccmode_bayer_bggr = 2,
    asn1Sccmode_bayer_gbrg = 3,
    asn1Sccmode_bayer_grbg = 4,
    asn1Sccmode_bayer_rggb = 5,
    asn1Sccmode_bgr = 6,
    asn1Sccmode_grayscale = 7,
    asn1Sccmode_jpeg = 8,
    asn1Sccmode_pjpg = 9,
    asn1Sccmode_png = 10,
    asn1Sccmode_rgb = 11,
    asn1Sccmode_rgb32 = 12,
    asn1Sccmode_undefined = 13,
    asn1Sccmode_uyvy = 14,
    asn1Sccraw_modes = 15
} asn1SccBase_samples_frame_frame_mode_t;

#define asn1SccBase_samples_frame_frame_mode_t_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_samples_frame_frame_mode_t_REQUIRED_BITS_FOR_ENCODING        4
#define asn1SccBase_samples_frame_frame_mode_t_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_samples_frame_frame_mode_t_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define asn1SccBase_samples_frame_frame_mode_t_REQUIRED_BYTES_FOR_XER_ENCODING   88

void asn1SccBase_samples_frame_frame_mode_t_Initialize(asn1SccBase_samples_frame_frame_mode_t* pVal);
flag asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_mode_t* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_frame_frame_mode_t_unknown_enumeration_value 
#define ERR_asn1SccBase_samples_frame_frame_mode_t_unknown_enumeration_value		1016  /**/
#endif
#ifndef ERR_asn1SccBase_samples_frame_frame_mode_t 
#define ERR_asn1SccBase_samples_frame_frame_mode_t		1015  /**/
#endif

typedef enum {
    asn1Sccstatus_empty = 0,
    asn1Sccstatus_invalid = 1,
    asn1Sccstatus_valid = 2
} asn1SccBase_samples_frame_frame_status_t;

#define asn1SccBase_samples_frame_frame_status_t_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccBase_samples_frame_frame_status_t_REQUIRED_BITS_FOR_ENCODING        2
#define asn1SccBase_samples_frame_frame_status_t_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccBase_samples_frame_frame_status_t_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define asn1SccBase_samples_frame_frame_status_t_REQUIRED_BYTES_FOR_XER_ENCODING   98

void asn1SccBase_samples_frame_frame_status_t_Initialize(asn1SccBase_samples_frame_frame_status_t* pVal);
flag asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_status_t* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_frame_frame_status_t_unknown_enumeration_value 
#define ERR_asn1SccBase_samples_frame_frame_status_t_unknown_enumeration_value		1018  /**/
#endif
#ifndef ERR_asn1SccBase_samples_frame_frame_status_t 
#define ERR_asn1SccBase_samples_frame_frame_status_t		1017  /**/
#endif

typedef enum {
    asn1Sccdegenerate = 0,
    asn1Sccpolynomial_bezier = 1,
    asn1Sccpolynomial_bspline = 2,
    asn1Sccrational_bezier = 3,
    asn1Sccrational_bspline = 4
} asn1SccWrappers_geometry_SplineType;

#define asn1SccWrappers_geometry_SplineType_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccWrappers_geometry_SplineType_REQUIRED_BITS_FOR_ENCODING        3
#define asn1SccWrappers_geometry_SplineType_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccWrappers_geometry_SplineType_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define asn1SccWrappers_geometry_SplineType_REQUIRED_BYTES_FOR_XER_ENCODING   96

void asn1SccWrappers_geometry_SplineType_Initialize(asn1SccWrappers_geometry_SplineType* pVal);
flag asn1SccWrappers_geometry_SplineType_IsConstraintValid(const asn1SccWrappers_geometry_SplineType* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_geometry_SplineType_unknown_enumeration_value 
#define ERR_asn1SccWrappers_geometry_SplineType_unknown_enumeration_value		1020  /**/
#endif
#ifndef ERR_asn1SccWrappers_geometry_SplineType 
#define ERR_asn1SccWrappers_geometry_SplineType		1019  /**/
#endif

typedef double asn1SccT_Double;

#define asn1SccT_Double_REQUIRED_BYTES_FOR_ENCODING       13 
#define asn1SccT_Double_REQUIRED_BITS_FOR_ENCODING        104
#define asn1SccT_Double_REQUIRED_BYTES_FOR_ACN_ENCODING   13 
#define asn1SccT_Double_REQUIRED_BITS_FOR_ACN_ENCODING    104
#define asn1SccT_Double_REQUIRED_BYTES_FOR_XER_ENCODING   71

void asn1SccT_Double_Initialize(asn1SccT_Double* pVal);
flag asn1SccT_Double_IsConstraintValid(const asn1SccT_Double* val, int* pErrCode);
#ifndef ERR_asn1SccT_Double 
#define ERR_asn1SccT_Double		1021  /*(-1.79769313486231570000E+308 .. 1.79769313486231570000E+308)*/
#endif

typedef struct {
    asn1SccT_Double rad;
} asn1SccBase_Angle;

#define asn1SccBase_Angle_REQUIRED_BYTES_FOR_ENCODING       13 
#define asn1SccBase_Angle_REQUIRED_BITS_FOR_ENCODING        104
#define asn1SccBase_Angle_REQUIRED_BYTES_FOR_ACN_ENCODING   13 
#define asn1SccBase_Angle_REQUIRED_BITS_FOR_ACN_ENCODING    104
#define asn1SccBase_Angle_REQUIRED_BYTES_FOR_XER_ENCODING   86

void asn1SccBase_Angle_Initialize(asn1SccBase_Angle* pVal);
flag asn1SccBase_Angle_IsConstraintValid(const asn1SccBase_Angle* val, int* pErrCode);


typedef struct {
    asn1SccT_Double translation;
    asn1SccT_Double rotation;
    asn1SccBase_Angle heading;
} asn1SccBase_commands_Motion2D;

#define asn1SccBase_commands_Motion2D_REQUIRED_BYTES_FOR_ENCODING       39 
#define asn1SccBase_commands_Motion2D_REQUIRED_BITS_FOR_ENCODING        312
#define asn1SccBase_commands_Motion2D_REQUIRED_BYTES_FOR_ACN_ENCODING   39 
#define asn1SccBase_commands_Motion2D_REQUIRED_BITS_FOR_ACN_ENCODING    312
#define asn1SccBase_commands_Motion2D_REQUIRED_BYTES_FOR_XER_ENCODING   277

void asn1SccBase_commands_Motion2D_Initialize(asn1SccBase_commands_Motion2D* pVal);
flag asn1SccBase_commands_Motion2D_IsConstraintValid(const asn1SccBase_commands_Motion2D* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_Angle arr[200];
} asn1SccBase_samples_Sonar_bearings;

#define asn1SccBase_samples_Sonar_bearings_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_Sonar_bearings_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_Sonar_bearings_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_Sonar_bearings_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_Sonar_bearings_REQUIRED_BYTES_FOR_XER_ENCODING   17259

void asn1SccBase_samples_Sonar_bearings_Initialize(asn1SccBase_samples_Sonar_bearings* pVal);
flag asn1SccBase_samples_Sonar_bearings_IsConstraintValid(const asn1SccBase_samples_Sonar_bearings* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Sonar_bearings 
#define ERR_asn1SccBase_samples_Sonar_bearings		1022  /*(SIZE(1 .. numBase-samples-Sonar-bearings))*/
#endif

typedef struct {
    asn1SccT_Double distance;
    asn1SccT_Double angle;
} asn1SccBase_PoseUpdateThreshold;

#define asn1SccBase_PoseUpdateThreshold_REQUIRED_BYTES_FOR_ENCODING       26 
#define asn1SccBase_PoseUpdateThreshold_REQUIRED_BITS_FOR_ENCODING        208
#define asn1SccBase_PoseUpdateThreshold_REQUIRED_BYTES_FOR_ACN_ENCODING   26 
#define asn1SccBase_PoseUpdateThreshold_REQUIRED_BITS_FOR_ACN_ENCODING    208
#define asn1SccBase_PoseUpdateThreshold_REQUIRED_BYTES_FOR_XER_ENCODING   189

void asn1SccBase_PoseUpdateThreshold_Initialize(asn1SccBase_PoseUpdateThreshold* pVal);
flag asn1SccBase_PoseUpdateThreshold_IsConstraintValid(const asn1SccBase_PoseUpdateThreshold* val, int* pErrCode);


typedef struct {
    asn1SccT_Double kelvin;
} asn1SccBase_Temperature;

#define asn1SccBase_Temperature_REQUIRED_BYTES_FOR_ENCODING       13 
#define asn1SccBase_Temperature_REQUIRED_BITS_FOR_ENCODING        104
#define asn1SccBase_Temperature_REQUIRED_BYTES_FOR_ACN_ENCODING   13 
#define asn1SccBase_Temperature_REQUIRED_BITS_FOR_ACN_ENCODING    104
#define asn1SccBase_Temperature_REQUIRED_BYTES_FOR_XER_ENCODING   104

void asn1SccBase_Temperature_Initialize(asn1SccBase_Temperature* pVal);
flag asn1SccBase_Temperature_IsConstraintValid(const asn1SccBase_Temperature* val, int* pErrCode);


typedef struct {
    asn1SccT_Double surge;
    asn1SccT_Double sway;
    asn1SccT_Double heave;
    asn1SccT_Double roll;
    asn1SccT_Double pitch;
    asn1SccT_Double yaw;
} asn1SccBase_commands_Speed6D;

#define asn1SccBase_commands_Speed6D_REQUIRED_BYTES_FOR_ENCODING       78 
#define asn1SccBase_commands_Speed6D_REQUIRED_BITS_FOR_ENCODING        624
#define asn1SccBase_commands_Speed6D_REQUIRED_BYTES_FOR_ACN_ENCODING   78 
#define asn1SccBase_commands_Speed6D_REQUIRED_BITS_FOR_ACN_ENCODING    624
#define asn1SccBase_commands_Speed6D_REQUIRED_BYTES_FOR_XER_ENCODING   429

void asn1SccBase_commands_Speed6D_Initialize(asn1SccBase_commands_Speed6D* pVal);
flag asn1SccBase_commands_Speed6D_IsConstraintValid(const asn1SccBase_commands_Speed6D* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[200];
} asn1SccWrappers_geometry_Spline_vertices;

#define asn1SccWrappers_geometry_Spline_vertices_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccWrappers_geometry_Spline_vertices_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccWrappers_geometry_Spline_vertices_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccWrappers_geometry_Spline_vertices_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccWrappers_geometry_Spline_vertices_REQUIRED_BYTES_FOR_XER_ENCODING   14271

void asn1SccWrappers_geometry_Spline_vertices_Initialize(asn1SccWrappers_geometry_Spline_vertices* pVal);
flag asn1SccWrappers_geometry_Spline_vertices_IsConstraintValid(const asn1SccWrappers_geometry_Spline_vertices* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_geometry_Spline_vertices 
#define ERR_asn1SccWrappers_geometry_Spline_vertices		1023  /*(SIZE(1 .. numWrappers-geometry-Spline-vertices))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Double arr[200];
} asn1SccWrappers_geometry_Spline_knots;

#define asn1SccWrappers_geometry_Spline_knots_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccWrappers_geometry_Spline_knots_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccWrappers_geometry_Spline_knots_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccWrappers_geometry_Spline_knots_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccWrappers_geometry_Spline_knots_REQUIRED_BYTES_FOR_XER_ENCODING   14265

void asn1SccWrappers_geometry_Spline_knots_Initialize(asn1SccWrappers_geometry_Spline_knots* pVal);
flag asn1SccWrappers_geometry_Spline_knots_IsConstraintValid(const asn1SccWrappers_geometry_Spline_knots* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_geometry_Spline_knots 
#define ERR_asn1SccWrappers_geometry_Spline_knots		1024  /*(SIZE(1 .. numWrappers-geometry-Spline-knots))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Double arr[200];
} asn1SccWrappers_VectorXd_data;

#define asn1SccWrappers_VectorXd_data_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccWrappers_VectorXd_data_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccWrappers_VectorXd_data_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccWrappers_VectorXd_data_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccWrappers_VectorXd_data_REQUIRED_BYTES_FOR_XER_ENCODING   14249

void asn1SccWrappers_VectorXd_data_Initialize(asn1SccWrappers_VectorXd_data* pVal);
flag asn1SccWrappers_VectorXd_data_IsConstraintValid(const asn1SccWrappers_VectorXd_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_VectorXd_data 
#define ERR_asn1SccWrappers_VectorXd_data		1025  /*(SIZE(1 .. numWrappers-VectorXd-data))*/
#endif

typedef struct {
    asn1SccWrappers_VectorXd_data data;
} asn1SccWrappers_VectorXd;

#define asn1SccWrappers_VectorXd_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccWrappers_VectorXd_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccWrappers_VectorXd_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccWrappers_VectorXd_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccWrappers_VectorXd_REQUIRED_BYTES_FOR_XER_ENCODING   14252

void asn1SccWrappers_VectorXd_Initialize(asn1SccWrappers_VectorXd* pVal);
flag asn1SccWrappers_VectorXd_IsConstraintValid(const asn1SccWrappers_VectorXd* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[3];
} asn1SccWrappers_Quaterniond_im;

#define asn1SccWrappers_Quaterniond_im_REQUIRED_BYTES_FOR_ENCODING       40 
#define asn1SccWrappers_Quaterniond_im_REQUIRED_BITS_FOR_ENCODING        314
#define asn1SccWrappers_Quaterniond_im_REQUIRED_BYTES_FOR_ACN_ENCODING   40 
#define asn1SccWrappers_Quaterniond_im_REQUIRED_BITS_FOR_ACN_ENCODING    314
#define asn1SccWrappers_Quaterniond_im_REQUIRED_BYTES_FOR_XER_ENCODING   264

void asn1SccWrappers_Quaterniond_im_Initialize(asn1SccWrappers_Quaterniond_im* pVal);
flag asn1SccWrappers_Quaterniond_im_IsConstraintValid(const asn1SccWrappers_Quaterniond_im* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Quaterniond_im 
#define ERR_asn1SccWrappers_Quaterniond_im		1026  /*(SIZE(1 .. 3))*/
#endif

typedef struct {
    asn1SccWrappers_Quaterniond_im im;
    asn1SccT_Double re;
} asn1SccWrappers_Quaterniond;

#define asn1SccWrappers_Quaterniond_REQUIRED_BYTES_FOR_ENCODING       53 
#define asn1SccWrappers_Quaterniond_REQUIRED_BITS_FOR_ENCODING        418
#define asn1SccWrappers_Quaterniond_REQUIRED_BYTES_FOR_ACN_ENCODING   53 
#define asn1SccWrappers_Quaterniond_REQUIRED_BITS_FOR_ACN_ENCODING    418
#define asn1SccWrappers_Quaterniond_REQUIRED_BYTES_FOR_XER_ENCODING   326

void asn1SccWrappers_Quaterniond_Initialize(asn1SccWrappers_Quaterniond* pVal);
flag asn1SccWrappers_Quaterniond_IsConstraintValid(const asn1SccWrappers_Quaterniond* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[200];
} asn1SccWrappers_MatrixXd_data;

#define asn1SccWrappers_MatrixXd_data_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccWrappers_MatrixXd_data_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccWrappers_MatrixXd_data_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccWrappers_MatrixXd_data_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccWrappers_MatrixXd_data_REQUIRED_BYTES_FOR_XER_ENCODING   14249

void asn1SccWrappers_MatrixXd_data_Initialize(asn1SccWrappers_MatrixXd_data* pVal);
flag asn1SccWrappers_MatrixXd_data_IsConstraintValid(const asn1SccWrappers_MatrixXd_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_MatrixXd_data 
#define ERR_asn1SccWrappers_MatrixXd_data		1027  /*(SIZE(1 .. numWrappers-MatrixXd-data))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Double arr[36];
} asn1SccWrappers_Matrix6d_data;

#define asn1SccWrappers_Matrix6d_data_REQUIRED_BYTES_FOR_ENCODING       469 
#define asn1SccWrappers_Matrix6d_data_REQUIRED_BITS_FOR_ENCODING        3750
#define asn1SccWrappers_Matrix6d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   469 
#define asn1SccWrappers_Matrix6d_data_REQUIRED_BITS_FOR_ACN_ENCODING    3750
#define asn1SccWrappers_Matrix6d_data_REQUIRED_BYTES_FOR_XER_ENCODING   2605

void asn1SccWrappers_Matrix6d_data_Initialize(asn1SccWrappers_Matrix6d_data* pVal);
flag asn1SccWrappers_Matrix6d_data_IsConstraintValid(const asn1SccWrappers_Matrix6d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Matrix6d_data 
#define ERR_asn1SccWrappers_Matrix6d_data		1028  /*(SIZE(1 .. 36))*/
#endif

typedef struct {
    asn1SccWrappers_Matrix6d_data data;
} asn1SccWrappers_Matrix6d;

#define asn1SccWrappers_Matrix6d_REQUIRED_BYTES_FOR_ENCODING       469 
#define asn1SccWrappers_Matrix6d_REQUIRED_BITS_FOR_ENCODING        3750
#define asn1SccWrappers_Matrix6d_REQUIRED_BYTES_FOR_ACN_ENCODING   469 
#define asn1SccWrappers_Matrix6d_REQUIRED_BITS_FOR_ACN_ENCODING    3750
#define asn1SccWrappers_Matrix6d_REQUIRED_BYTES_FOR_XER_ENCODING   2608

void asn1SccWrappers_Matrix6d_Initialize(asn1SccWrappers_Matrix6d* pVal);
flag asn1SccWrappers_Matrix6d_IsConstraintValid(const asn1SccWrappers_Matrix6d* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[6];
} asn1SccWrappers_Vector6d_data;

#define asn1SccWrappers_Vector6d_data_REQUIRED_BYTES_FOR_ENCODING       79 
#define asn1SccWrappers_Vector6d_data_REQUIRED_BITS_FOR_ENCODING        627
#define asn1SccWrappers_Vector6d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   79 
#define asn1SccWrappers_Vector6d_data_REQUIRED_BITS_FOR_ACN_ENCODING    627
#define asn1SccWrappers_Vector6d_data_REQUIRED_BYTES_FOR_XER_ENCODING   475

void asn1SccWrappers_Vector6d_data_Initialize(asn1SccWrappers_Vector6d_data* pVal);
flag asn1SccWrappers_Vector6d_data_IsConstraintValid(const asn1SccWrappers_Vector6d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Vector6d_data 
#define ERR_asn1SccWrappers_Vector6d_data		1029  /*(SIZE(1 .. 6))*/
#endif

typedef struct {
    asn1SccWrappers_Vector6d_data data;
} asn1SccWrappers_Vector6d;

#define asn1SccWrappers_Vector6d_REQUIRED_BYTES_FOR_ENCODING       79 
#define asn1SccWrappers_Vector6d_REQUIRED_BITS_FOR_ENCODING        627
#define asn1SccWrappers_Vector6d_REQUIRED_BYTES_FOR_ACN_ENCODING   79 
#define asn1SccWrappers_Vector6d_REQUIRED_BITS_FOR_ACN_ENCODING    627
#define asn1SccWrappers_Vector6d_REQUIRED_BYTES_FOR_XER_ENCODING   478

void asn1SccWrappers_Vector6d_Initialize(asn1SccWrappers_Vector6d* pVal);
flag asn1SccWrappers_Vector6d_IsConstraintValid(const asn1SccWrappers_Vector6d* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[16];
} asn1SccWrappers_Matrix4d_data;

#define asn1SccWrappers_Matrix4d_data_REQUIRED_BYTES_FOR_ENCODING       209 
#define asn1SccWrappers_Matrix4d_data_REQUIRED_BITS_FOR_ENCODING        1668
#define asn1SccWrappers_Matrix4d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   209 
#define asn1SccWrappers_Matrix4d_data_REQUIRED_BITS_FOR_ACN_ENCODING    1668
#define asn1SccWrappers_Matrix4d_data_REQUIRED_BYTES_FOR_XER_ENCODING   1185

void asn1SccWrappers_Matrix4d_data_Initialize(asn1SccWrappers_Matrix4d_data* pVal);
flag asn1SccWrappers_Matrix4d_data_IsConstraintValid(const asn1SccWrappers_Matrix4d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Matrix4d_data 
#define ERR_asn1SccWrappers_Matrix4d_data		1030  /*(SIZE(1 .. 16))*/
#endif

typedef struct {
    asn1SccWrappers_Matrix4d_data data;
} asn1SccWrappers_Matrix4d;

#define asn1SccWrappers_Matrix4d_REQUIRED_BYTES_FOR_ENCODING       209 
#define asn1SccWrappers_Matrix4d_REQUIRED_BITS_FOR_ENCODING        1668
#define asn1SccWrappers_Matrix4d_REQUIRED_BYTES_FOR_ACN_ENCODING   209 
#define asn1SccWrappers_Matrix4d_REQUIRED_BITS_FOR_ACN_ENCODING    1668
#define asn1SccWrappers_Matrix4d_REQUIRED_BYTES_FOR_XER_ENCODING   1188

void asn1SccWrappers_Matrix4d_Initialize(asn1SccWrappers_Matrix4d* pVal);
flag asn1SccWrappers_Matrix4d_IsConstraintValid(const asn1SccWrappers_Matrix4d* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[4];
} asn1SccWrappers_Vector4d_data;

#define asn1SccWrappers_Vector4d_data_REQUIRED_BYTES_FOR_ENCODING       53 
#define asn1SccWrappers_Vector4d_data_REQUIRED_BITS_FOR_ENCODING        418
#define asn1SccWrappers_Vector4d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   53 
#define asn1SccWrappers_Vector4d_data_REQUIRED_BITS_FOR_ACN_ENCODING    418
#define asn1SccWrappers_Vector4d_data_REQUIRED_BYTES_FOR_XER_ENCODING   333

void asn1SccWrappers_Vector4d_data_Initialize(asn1SccWrappers_Vector4d_data* pVal);
flag asn1SccWrappers_Vector4d_data_IsConstraintValid(const asn1SccWrappers_Vector4d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Vector4d_data 
#define ERR_asn1SccWrappers_Vector4d_data		1031  /*(SIZE(1 .. 4))*/
#endif

typedef struct {
    asn1SccWrappers_Vector4d_data data;
} asn1SccWrappers_Vector4d;

#define asn1SccWrappers_Vector4d_REQUIRED_BYTES_FOR_ENCODING       53 
#define asn1SccWrappers_Vector4d_REQUIRED_BITS_FOR_ENCODING        418
#define asn1SccWrappers_Vector4d_REQUIRED_BYTES_FOR_ACN_ENCODING   53 
#define asn1SccWrappers_Vector4d_REQUIRED_BITS_FOR_ACN_ENCODING    418
#define asn1SccWrappers_Vector4d_REQUIRED_BYTES_FOR_XER_ENCODING   336

void asn1SccWrappers_Vector4d_Initialize(asn1SccWrappers_Vector4d* pVal);
flag asn1SccWrappers_Vector4d_IsConstraintValid(const asn1SccWrappers_Vector4d* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccWrappers_Vector4d arr[200];
} asn1SccStd_vector_Wrappers_Vector4d;

#define asn1SccStd_vector_Wrappers_Vector4d_REQUIRED_BYTES_FOR_ENCODING       10451 
#define asn1SccStd_vector_Wrappers_Vector4d_REQUIRED_BITS_FOR_ENCODING        83608
#define asn1SccStd_vector_Wrappers_Vector4d_REQUIRED_BYTES_FOR_ACN_ENCODING   10451 
#define asn1SccStd_vector_Wrappers_Vector4d_REQUIRED_BITS_FOR_ACN_ENCODING    83608
#define asn1SccStd_vector_Wrappers_Vector4d_REQUIRED_BYTES_FOR_XER_ENCODING   67261

void asn1SccStd_vector_Wrappers_Vector4d_Initialize(asn1SccStd_vector_Wrappers_Vector4d* pVal);
flag asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(const asn1SccStd_vector_Wrappers_Vector4d* val, int* pErrCode);
#ifndef ERR_asn1SccStd_vector_Wrappers_Vector4d 
#define ERR_asn1SccStd_vector_Wrappers_Vector4d		1032  /*(SIZE(1 .. numStd-vector-Wrappers-Vector4d))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccWrappers_Vector4d arr[200];
} asn1SccBase_samples_Pointcloud_m_colors;

#define asn1SccBase_samples_Pointcloud_m_colors_REQUIRED_BYTES_FOR_ENCODING       10451 
#define asn1SccBase_samples_Pointcloud_m_colors_REQUIRED_BITS_FOR_ENCODING        83608
#define asn1SccBase_samples_Pointcloud_m_colors_REQUIRED_BYTES_FOR_ACN_ENCODING   10451 
#define asn1SccBase_samples_Pointcloud_m_colors_REQUIRED_BITS_FOR_ACN_ENCODING    83608
#define asn1SccBase_samples_Pointcloud_m_colors_REQUIRED_BYTES_FOR_XER_ENCODING   67269

void asn1SccBase_samples_Pointcloud_m_colors_Initialize(asn1SccBase_samples_Pointcloud_m_colors* pVal);
flag asn1SccBase_samples_Pointcloud_m_colors_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m_colors* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Pointcloud_m_colors 
#define ERR_asn1SccBase_samples_Pointcloud_m_colors		1033  /*(SIZE(1 .. numBase-samples-Pointcloud-m-colors))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccWrappers_Vector4d arr[200];
} asn1SccBase_samples_Pointcloud_colors;

#define asn1SccBase_samples_Pointcloud_colors_REQUIRED_BYTES_FOR_ENCODING       10451 
#define asn1SccBase_samples_Pointcloud_colors_REQUIRED_BITS_FOR_ENCODING        83608
#define asn1SccBase_samples_Pointcloud_colors_REQUIRED_BYTES_FOR_ACN_ENCODING   10451 
#define asn1SccBase_samples_Pointcloud_colors_REQUIRED_BITS_FOR_ACN_ENCODING    83608
#define asn1SccBase_samples_Pointcloud_colors_REQUIRED_BYTES_FOR_XER_ENCODING   67265

void asn1SccBase_samples_Pointcloud_colors_Initialize(asn1SccBase_samples_Pointcloud_colors* pVal);
flag asn1SccBase_samples_Pointcloud_colors_IsConstraintValid(const asn1SccBase_samples_Pointcloud_colors* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Pointcloud_colors 
#define ERR_asn1SccBase_samples_Pointcloud_colors		1034  /*(SIZE(1 .. numBase-samples-Pointcloud-colors))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Double arr[9];
} asn1SccWrappers_Matrix3d_data;

#define asn1SccWrappers_Matrix3d_data_REQUIRED_BYTES_FOR_ENCODING       118 
#define asn1SccWrappers_Matrix3d_data_REQUIRED_BITS_FOR_ENCODING        940
#define asn1SccWrappers_Matrix3d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   118 
#define asn1SccWrappers_Matrix3d_data_REQUIRED_BITS_FOR_ACN_ENCODING    940
#define asn1SccWrappers_Matrix3d_data_REQUIRED_BYTES_FOR_XER_ENCODING   688

void asn1SccWrappers_Matrix3d_data_Initialize(asn1SccWrappers_Matrix3d_data* pVal);
flag asn1SccWrappers_Matrix3d_data_IsConstraintValid(const asn1SccWrappers_Matrix3d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Matrix3d_data 
#define ERR_asn1SccWrappers_Matrix3d_data		1035  /*(SIZE(1 .. 9))*/
#endif

typedef struct {
    asn1SccWrappers_Matrix3d_data data;
} asn1SccWrappers_Matrix3d;

#define asn1SccWrappers_Matrix3d_REQUIRED_BYTES_FOR_ENCODING       118 
#define asn1SccWrappers_Matrix3d_REQUIRED_BITS_FOR_ENCODING        940
#define asn1SccWrappers_Matrix3d_REQUIRED_BYTES_FOR_ACN_ENCODING   118 
#define asn1SccWrappers_Matrix3d_REQUIRED_BITS_FOR_ACN_ENCODING    940
#define asn1SccWrappers_Matrix3d_REQUIRED_BYTES_FOR_XER_ENCODING   691

void asn1SccWrappers_Matrix3d_Initialize(asn1SccWrappers_Matrix3d* pVal);
flag asn1SccWrappers_Matrix3d_IsConstraintValid(const asn1SccWrappers_Matrix3d* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[3];
} asn1SccWrappers_Vector3d_data;

#define asn1SccWrappers_Vector3d_data_REQUIRED_BYTES_FOR_ENCODING       40 
#define asn1SccWrappers_Vector3d_data_REQUIRED_BITS_FOR_ENCODING        314
#define asn1SccWrappers_Vector3d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   40 
#define asn1SccWrappers_Vector3d_data_REQUIRED_BITS_FOR_ACN_ENCODING    314
#define asn1SccWrappers_Vector3d_data_REQUIRED_BYTES_FOR_XER_ENCODING   262

void asn1SccWrappers_Vector3d_data_Initialize(asn1SccWrappers_Vector3d_data* pVal);
flag asn1SccWrappers_Vector3d_data_IsConstraintValid(const asn1SccWrappers_Vector3d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Vector3d_data 
#define ERR_asn1SccWrappers_Vector3d_data		1036  /*(SIZE(1 .. 3))*/
#endif

typedef struct {
    asn1SccWrappers_Vector3d_data data;
} asn1SccWrappers_Vector3d;

#define asn1SccWrappers_Vector3d_REQUIRED_BYTES_FOR_ENCODING       40 
#define asn1SccWrappers_Vector3d_REQUIRED_BITS_FOR_ENCODING        314
#define asn1SccWrappers_Vector3d_REQUIRED_BYTES_FOR_ACN_ENCODING   40 
#define asn1SccWrappers_Vector3d_REQUIRED_BITS_FOR_ACN_ENCODING    314
#define asn1SccWrappers_Vector3d_REQUIRED_BYTES_FOR_XER_ENCODING   265

void asn1SccWrappers_Vector3d_Initialize(asn1SccWrappers_Vector3d* pVal);
flag asn1SccWrappers_Vector3d_IsConstraintValid(const asn1SccWrappers_Vector3d* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d position;
    asn1SccWrappers_Quaterniond orientation;
} asn1SccBase_Pose;

#define asn1SccBase_Pose_REQUIRED_BYTES_FOR_ENCODING       92 
#define asn1SccBase_Pose_REQUIRED_BITS_FOR_ENCODING        732
#define asn1SccBase_Pose_REQUIRED_BYTES_FOR_ACN_ENCODING   92 
#define asn1SccBase_Pose_REQUIRED_BITS_FOR_ACN_ENCODING    732
#define asn1SccBase_Pose_REQUIRED_BYTES_FOR_XER_ENCODING   578

void asn1SccBase_Pose_Initialize(asn1SccBase_Pose* pVal);
flag asn1SccBase_Pose_IsConstraintValid(const asn1SccBase_Pose* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d translation;
    asn1SccWrappers_Quaterniond orientation;
    asn1SccWrappers_Matrix6d cov;
} asn1SccBase_TransformWithCovariance;

#define asn1SccBase_TransformWithCovariance_REQUIRED_BYTES_FOR_ENCODING       561 
#define asn1SccBase_TransformWithCovariance_REQUIRED_BITS_FOR_ENCODING        4482
#define asn1SccBase_TransformWithCovariance_REQUIRED_BYTES_FOR_ACN_ENCODING   561 
#define asn1SccBase_TransformWithCovariance_REQUIRED_BITS_FOR_ACN_ENCODING    4482
#define asn1SccBase_TransformWithCovariance_REQUIRED_BYTES_FOR_XER_ENCODING   3202

void asn1SccBase_TransformWithCovariance_Initialize(asn1SccBase_TransformWithCovariance* pVal);
flag asn1SccBase_TransformWithCovariance_IsConstraintValid(const asn1SccBase_TransformWithCovariance* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d vel;
    asn1SccWrappers_Vector3d rot;
    asn1SccWrappers_Matrix6d cov;
} asn1SccBase_TwistWithCovariance;

#define asn1SccBase_TwistWithCovariance_REQUIRED_BYTES_FOR_ENCODING       548 
#define asn1SccBase_TwistWithCovariance_REQUIRED_BITS_FOR_ENCODING        4378
#define asn1SccBase_TwistWithCovariance_REQUIRED_BYTES_FOR_ACN_ENCODING   548 
#define asn1SccBase_TwistWithCovariance_REQUIRED_BITS_FOR_ACN_ENCODING    4378
#define asn1SccBase_TwistWithCovariance_REQUIRED_BYTES_FOR_XER_ENCODING   3107

void asn1SccBase_TwistWithCovariance_Initialize(asn1SccBase_TwistWithCovariance* pVal);
flag asn1SccBase_TwistWithCovariance_IsConstraintValid(const asn1SccBase_TwistWithCovariance* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d force;
    asn1SccWrappers_Vector3d torque;
} asn1SccBase_Wrench;

#define asn1SccBase_Wrench_REQUIRED_BYTES_FOR_ENCODING       79 
#define asn1SccBase_Wrench_REQUIRED_BITS_FOR_ENCODING        628
#define asn1SccBase_Wrench_REQUIRED_BYTES_FOR_ACN_ENCODING   79 
#define asn1SccBase_Wrench_REQUIRED_BITS_FOR_ACN_ENCODING    628
#define asn1SccBase_Wrench_REQUIRED_BYTES_FOR_XER_ENCODING   511

void asn1SccBase_Wrench_Initialize(asn1SccBase_Wrench* pVal);
flag asn1SccBase_Wrench_IsConstraintValid(const asn1SccBase_Wrench* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_Wrench arr[200];
} asn1SccBase_samples_Wrenches_elements;

#define asn1SccBase_samples_Wrenches_elements_REQUIRED_BYTES_FOR_ENCODING       15701 
#define asn1SccBase_samples_Wrenches_elements_REQUIRED_BITS_FOR_ENCODING        125608
#define asn1SccBase_samples_Wrenches_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   15701 
#define asn1SccBase_samples_Wrenches_elements_REQUIRED_BITS_FOR_ACN_ENCODING    125608
#define asn1SccBase_samples_Wrenches_elements_REQUIRED_BYTES_FOR_XER_ENCODING   102265

void asn1SccBase_samples_Wrenches_elements_Initialize(asn1SccBase_samples_Wrenches_elements* pVal);
flag asn1SccBase_samples_Wrenches_elements_IsConstraintValid(const asn1SccBase_samples_Wrenches_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Wrenches_elements 
#define ERR_asn1SccBase_samples_Wrenches_elements		1037  /*(SIZE(1 .. numBase-samples-Wrenches-elements))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_Wrench arr[200];
} asn1SccBase_NamedVector_Base_Wrench_elements;

#define asn1SccBase_NamedVector_Base_Wrench_elements_REQUIRED_BYTES_FOR_ENCODING       15701 
#define asn1SccBase_NamedVector_Base_Wrench_elements_REQUIRED_BITS_FOR_ENCODING        125608
#define asn1SccBase_NamedVector_Base_Wrench_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   15701 
#define asn1SccBase_NamedVector_Base_Wrench_elements_REQUIRED_BITS_FOR_ACN_ENCODING    125608
#define asn1SccBase_NamedVector_Base_Wrench_elements_REQUIRED_BYTES_FOR_XER_ENCODING   102279

void asn1SccBase_NamedVector_Base_Wrench_elements_Initialize(asn1SccBase_NamedVector_Base_Wrench_elements* pVal);
flag asn1SccBase_NamedVector_Base_Wrench_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_Wrench_elements 
#define ERR_asn1SccBase_NamedVector_Base_Wrench_elements		1038  /*(SIZE(1 .. numBase-NamedVector-Base-Wrench-elements))*/
#endif

typedef struct {
    asn1SccWrappers_Vector3d position;
    asn1SccT_Double heading;
    asn1SccT_Double tol_position;
    asn1SccT_Double tol_heading;
} asn1SccBase_Waypoint;

#define asn1SccBase_Waypoint_REQUIRED_BYTES_FOR_ENCODING       79 
#define asn1SccBase_Waypoint_REQUIRED_BITS_FOR_ENCODING        626
#define asn1SccBase_Waypoint_REQUIRED_BYTES_FOR_ACN_ENCODING   79 
#define asn1SccBase_Waypoint_REQUIRED_BITS_FOR_ACN_ENCODING    626
#define asn1SccBase_Waypoint_REQUIRED_BYTES_FOR_XER_ENCODING   503

void asn1SccBase_Waypoint_Initialize(asn1SccBase_Waypoint* pVal);
flag asn1SccBase_Waypoint_IsConstraintValid(const asn1SccBase_Waypoint* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d position;
    asn1SccWrappers_Quaterniond orientation;
} asn1SccBase_Pose_m;

#define asn1SccBase_Pose_m_REQUIRED_BYTES_FOR_ENCODING       92 
#define asn1SccBase_Pose_m_REQUIRED_BITS_FOR_ENCODING        732
#define asn1SccBase_Pose_m_REQUIRED_BYTES_FOR_ACN_ENCODING   92 
#define asn1SccBase_Pose_m_REQUIRED_BITS_FOR_ACN_ENCODING    732
#define asn1SccBase_Pose_m_REQUIRED_BYTES_FOR_XER_ENCODING   582

void asn1SccBase_Pose_m_Initialize(asn1SccBase_Pose_m* pVal);
flag asn1SccBase_Pose_m_IsConstraintValid(const asn1SccBase_Pose_m* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d translation;
    asn1SccWrappers_Quaterniond orientation;
    asn1SccWrappers_Matrix6d cov;
} asn1SccBase_TransformWithCovariance_m;

#define asn1SccBase_TransformWithCovariance_m_REQUIRED_BYTES_FOR_ENCODING       561 
#define asn1SccBase_TransformWithCovariance_m_REQUIRED_BITS_FOR_ENCODING        4482
#define asn1SccBase_TransformWithCovariance_m_REQUIRED_BYTES_FOR_ACN_ENCODING   561 
#define asn1SccBase_TransformWithCovariance_m_REQUIRED_BITS_FOR_ACN_ENCODING    4482
#define asn1SccBase_TransformWithCovariance_m_REQUIRED_BYTES_FOR_XER_ENCODING   3206

void asn1SccBase_TransformWithCovariance_m_Initialize(asn1SccBase_TransformWithCovariance_m* pVal);
flag asn1SccBase_TransformWithCovariance_m_IsConstraintValid(const asn1SccBase_TransformWithCovariance_m* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d vel;
    asn1SccWrappers_Vector3d rot;
    asn1SccWrappers_Matrix6d cov;
} asn1SccBase_TwistWithCovariance_m;

#define asn1SccBase_TwistWithCovariance_m_REQUIRED_BYTES_FOR_ENCODING       548 
#define asn1SccBase_TwistWithCovariance_m_REQUIRED_BITS_FOR_ENCODING        4378
#define asn1SccBase_TwistWithCovariance_m_REQUIRED_BYTES_FOR_ACN_ENCODING   548 
#define asn1SccBase_TwistWithCovariance_m_REQUIRED_BITS_FOR_ACN_ENCODING    4378
#define asn1SccBase_TwistWithCovariance_m_REQUIRED_BYTES_FOR_XER_ENCODING   3111

void asn1SccBase_TwistWithCovariance_m_Initialize(asn1SccBase_TwistWithCovariance_m* pVal);
flag asn1SccBase_TwistWithCovariance_m_IsConstraintValid(const asn1SccBase_TwistWithCovariance_m* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d position;
    asn1SccT_Double heading;
    asn1SccT_Double tol_position;
    asn1SccT_Double tol_heading;
} asn1SccBase_Waypoint_m;

#define asn1SccBase_Waypoint_m_REQUIRED_BYTES_FOR_ENCODING       79 
#define asn1SccBase_Waypoint_m_REQUIRED_BITS_FOR_ENCODING        626
#define asn1SccBase_Waypoint_m_REQUIRED_BYTES_FOR_ACN_ENCODING   79 
#define asn1SccBase_Waypoint_m_REQUIRED_BITS_FOR_ACN_ENCODING    626
#define asn1SccBase_Waypoint_m_REQUIRED_BYTES_FOR_XER_ENCODING   507

void asn1SccBase_Waypoint_m_Initialize(asn1SccBase_Waypoint_m* pVal);
flag asn1SccBase_Waypoint_m_IsConstraintValid(const asn1SccBase_Waypoint_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_Waypoint_m arr[200];
} asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint;

#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BYTES_FOR_ENCODING       15651 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BITS_FOR_ENCODING        125208
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BYTES_FOR_ACN_ENCODING   15651 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BITS_FOR_ACN_ENCODING    125208
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BYTES_FOR_XER_ENCODING   101505

void asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal);
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* val, int* pErrCode);
#ifndef ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint 
#define ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint		1039  /*(SIZE(1 .. numStd-orogen-typekits-mtype-std-vector-base-Waypoint))*/
#endif

typedef struct {
    asn1SccWrappers_Vector3d force;
    asn1SccWrappers_Vector3d torque;
} asn1SccBase_Wrench_m;

#define asn1SccBase_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       79 
#define asn1SccBase_Wrench_m_REQUIRED_BITS_FOR_ENCODING        628
#define asn1SccBase_Wrench_m_REQUIRED_BYTES_FOR_ACN_ENCODING   79 
#define asn1SccBase_Wrench_m_REQUIRED_BITS_FOR_ACN_ENCODING    628
#define asn1SccBase_Wrench_m_REQUIRED_BYTES_FOR_XER_ENCODING   515

void asn1SccBase_Wrench_m_Initialize(asn1SccBase_Wrench_m* pVal);
flag asn1SccBase_Wrench_m_IsConstraintValid(const asn1SccBase_Wrench_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_Wrench_m arr[200];
} asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench;

#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BYTES_FOR_ENCODING       15701 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BITS_FOR_ENCODING        125608
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BYTES_FOR_ACN_ENCODING   15701 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BITS_FOR_ACN_ENCODING    125608
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BYTES_FOR_XER_ENCODING   103101

void asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal);
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* val, int* pErrCode);
#ifndef ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench 
#define ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench		1040  /*(SIZE(1 .. numStd-orogen-typekits-mtype-std-vector-base-Wrench))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccWrappers_Vector3d arr[200];
} asn1SccBase_samples_Pointcloud_m_points;

#define asn1SccBase_samples_Pointcloud_m_points_REQUIRED_BYTES_FOR_ENCODING       7851 
#define asn1SccBase_samples_Pointcloud_m_points_REQUIRED_BITS_FOR_ENCODING        62808
#define asn1SccBase_samples_Pointcloud_m_points_REQUIRED_BYTES_FOR_ACN_ENCODING   7851 
#define asn1SccBase_samples_Pointcloud_m_points_REQUIRED_BITS_FOR_ACN_ENCODING    62808
#define asn1SccBase_samples_Pointcloud_m_points_REQUIRED_BYTES_FOR_XER_ENCODING   53069

void asn1SccBase_samples_Pointcloud_m_points_Initialize(asn1SccBase_samples_Pointcloud_m_points* pVal);
flag asn1SccBase_samples_Pointcloud_m_points_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m_points* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Pointcloud_m_points 
#define ERR_asn1SccBase_samples_Pointcloud_m_points		1041  /*(SIZE(1 .. numBase-samples-Pointcloud-m-points))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccWrappers_Vector3d arr[200];
} asn1SccBase_samples_Pointcloud_points;

#define asn1SccBase_samples_Pointcloud_points_REQUIRED_BYTES_FOR_ENCODING       7851 
#define asn1SccBase_samples_Pointcloud_points_REQUIRED_BITS_FOR_ENCODING        62808
#define asn1SccBase_samples_Pointcloud_points_REQUIRED_BYTES_FOR_ACN_ENCODING   7851 
#define asn1SccBase_samples_Pointcloud_points_REQUIRED_BITS_FOR_ACN_ENCODING    62808
#define asn1SccBase_samples_Pointcloud_points_REQUIRED_BYTES_FOR_XER_ENCODING   53065

void asn1SccBase_samples_Pointcloud_points_Initialize(asn1SccBase_samples_Pointcloud_points* pVal);
flag asn1SccBase_samples_Pointcloud_points_IsConstraintValid(const asn1SccBase_samples_Pointcloud_points* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Pointcloud_points 
#define ERR_asn1SccBase_samples_Pointcloud_points		1042  /*(SIZE(1 .. numBase-samples-Pointcloud-points))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Double arr[4];
} asn1SccWrappers_Matrix2d_data;

#define asn1SccWrappers_Matrix2d_data_REQUIRED_BYTES_FOR_ENCODING       53 
#define asn1SccWrappers_Matrix2d_data_REQUIRED_BITS_FOR_ENCODING        418
#define asn1SccWrappers_Matrix2d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   53 
#define asn1SccWrappers_Matrix2d_data_REQUIRED_BITS_FOR_ACN_ENCODING    418
#define asn1SccWrappers_Matrix2d_data_REQUIRED_BYTES_FOR_XER_ENCODING   333

void asn1SccWrappers_Matrix2d_data_Initialize(asn1SccWrappers_Matrix2d_data* pVal);
flag asn1SccWrappers_Matrix2d_data_IsConstraintValid(const asn1SccWrappers_Matrix2d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Matrix2d_data 
#define ERR_asn1SccWrappers_Matrix2d_data		1043  /*(SIZE(1 .. 4))*/
#endif

typedef struct {
    asn1SccWrappers_Matrix2d_data data;
} asn1SccWrappers_Matrix2d;

#define asn1SccWrappers_Matrix2d_REQUIRED_BYTES_FOR_ENCODING       53 
#define asn1SccWrappers_Matrix2d_REQUIRED_BITS_FOR_ENCODING        418
#define asn1SccWrappers_Matrix2d_REQUIRED_BYTES_FOR_ACN_ENCODING   53 
#define asn1SccWrappers_Matrix2d_REQUIRED_BITS_FOR_ACN_ENCODING    418
#define asn1SccWrappers_Matrix2d_REQUIRED_BYTES_FOR_XER_ENCODING   336

void asn1SccWrappers_Matrix2d_Initialize(asn1SccWrappers_Matrix2d* pVal);
flag asn1SccWrappers_Matrix2d_IsConstraintValid(const asn1SccWrappers_Matrix2d* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[2];
} asn1SccWrappers_Vector2d_data;

#define asn1SccWrappers_Vector2d_data_REQUIRED_BYTES_FOR_ENCODING       27 
#define asn1SccWrappers_Vector2d_data_REQUIRED_BITS_FOR_ENCODING        209
#define asn1SccWrappers_Vector2d_data_REQUIRED_BYTES_FOR_ACN_ENCODING   27 
#define asn1SccWrappers_Vector2d_data_REQUIRED_BITS_FOR_ACN_ENCODING    209
#define asn1SccWrappers_Vector2d_data_REQUIRED_BYTES_FOR_XER_ENCODING   191

void asn1SccWrappers_Vector2d_data_Initialize(asn1SccWrappers_Vector2d_data* pVal);
flag asn1SccWrappers_Vector2d_data_IsConstraintValid(const asn1SccWrappers_Vector2d_data* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_Vector2d_data 
#define ERR_asn1SccWrappers_Vector2d_data		1044  /*(SIZE(1 .. 2))*/
#endif

typedef struct {
    asn1SccWrappers_Vector2d_data data;
} asn1SccWrappers_Vector2d;

#define asn1SccWrappers_Vector2d_REQUIRED_BYTES_FOR_ENCODING       27 
#define asn1SccWrappers_Vector2d_REQUIRED_BITS_FOR_ENCODING        209
#define asn1SccWrappers_Vector2d_REQUIRED_BYTES_FOR_ACN_ENCODING   27 
#define asn1SccWrappers_Vector2d_REQUIRED_BITS_FOR_ACN_ENCODING    209
#define asn1SccWrappers_Vector2d_REQUIRED_BYTES_FOR_XER_ENCODING   194

void asn1SccWrappers_Vector2d_Initialize(asn1SccWrappers_Vector2d* pVal);
flag asn1SccWrappers_Vector2d_IsConstraintValid(const asn1SccWrappers_Vector2d* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector2d position;
    asn1SccT_Double orientation;
} asn1SccBase_Pose2D;

#define asn1SccBase_Pose2D_REQUIRED_BYTES_FOR_ENCODING       40 
#define asn1SccBase_Pose2D_REQUIRED_BITS_FOR_ENCODING        313
#define asn1SccBase_Pose2D_REQUIRED_BYTES_FOR_ACN_ENCODING   40 
#define asn1SccBase_Pose2D_REQUIRED_BITS_FOR_ACN_ENCODING    313
#define asn1SccBase_Pose2D_REQUIRED_BYTES_FOR_XER_ENCODING   280

void asn1SccBase_Pose2D_Initialize(asn1SccBase_Pose2D* pVal);
flag asn1SccBase_Pose2D_IsConstraintValid(const asn1SccBase_Pose2D* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector2d position;
    asn1SccT_Double orientation;
} asn1SccBase_Pose2D_m;

#define asn1SccBase_Pose2D_m_REQUIRED_BYTES_FOR_ENCODING       40 
#define asn1SccBase_Pose2D_m_REQUIRED_BITS_FOR_ENCODING        313
#define asn1SccBase_Pose2D_m_REQUIRED_BYTES_FOR_ACN_ENCODING   40 
#define asn1SccBase_Pose2D_m_REQUIRED_BITS_FOR_ACN_ENCODING    313
#define asn1SccBase_Pose2D_m_REQUIRED_BYTES_FOR_XER_ENCODING   284

void asn1SccBase_Pose2D_m_Initialize(asn1SccBase_Pose2D_m* pVal);
flag asn1SccBase_Pose2D_m_IsConstraintValid(const asn1SccBase_Pose2D_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[3];
} asn1SccWrappers_AngleAxisd_axis;

#define asn1SccWrappers_AngleAxisd_axis_REQUIRED_BYTES_FOR_ENCODING       40 
#define asn1SccWrappers_AngleAxisd_axis_REQUIRED_BITS_FOR_ENCODING        314
#define asn1SccWrappers_AngleAxisd_axis_REQUIRED_BYTES_FOR_ACN_ENCODING   40 
#define asn1SccWrappers_AngleAxisd_axis_REQUIRED_BITS_FOR_ACN_ENCODING    314
#define asn1SccWrappers_AngleAxisd_axis_REQUIRED_BYTES_FOR_XER_ENCODING   266

void asn1SccWrappers_AngleAxisd_axis_Initialize(asn1SccWrappers_AngleAxisd_axis* pVal);
flag asn1SccWrappers_AngleAxisd_axis_IsConstraintValid(const asn1SccWrappers_AngleAxisd_axis* val, int* pErrCode);
#ifndef ERR_asn1SccWrappers_AngleAxisd_axis 
#define ERR_asn1SccWrappers_AngleAxisd_axis		1045  /*(SIZE(1 .. 3))*/
#endif

typedef struct {
    asn1SccT_Double angle;
    asn1SccWrappers_AngleAxisd_axis axis;
} asn1SccWrappers_AngleAxisd;

#define asn1SccWrappers_AngleAxisd_REQUIRED_BYTES_FOR_ENCODING       53 
#define asn1SccWrappers_AngleAxisd_REQUIRED_BITS_FOR_ENCODING        418
#define asn1SccWrappers_AngleAxisd_REQUIRED_BYTES_FOR_ACN_ENCODING   53 
#define asn1SccWrappers_AngleAxisd_REQUIRED_BITS_FOR_ACN_ENCODING    418
#define asn1SccWrappers_AngleAxisd_REQUIRED_BYTES_FOR_XER_ENCODING   334

void asn1SccWrappers_AngleAxisd_Initialize(asn1SccWrappers_AngleAxisd* pVal);
flag asn1SccWrappers_AngleAxisd_IsConstraintValid(const asn1SccWrappers_AngleAxisd* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Double arr[200];
} asn1SccBase_samples_DepthMap_horizontal_interval;

#define asn1SccBase_samples_DepthMap_horizontal_interval_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_DepthMap_horizontal_interval_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_DepthMap_horizontal_interval_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_DepthMap_horizontal_interval_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_DepthMap_horizontal_interval_REQUIRED_BYTES_FOR_XER_ENCODING   14287

void asn1SccBase_samples_DepthMap_horizontal_interval_Initialize(asn1SccBase_samples_DepthMap_horizontal_interval* pVal);
flag asn1SccBase_samples_DepthMap_horizontal_interval_IsConstraintValid(const asn1SccBase_samples_DepthMap_horizontal_interval* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_horizontal_interval 
#define ERR_asn1SccBase_samples_DepthMap_horizontal_interval		1046  /*(SIZE(1 .. numBase-samples-DepthMap-horizontal-interval))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Double arr[200];
} asn1SccBase_samples_DepthMap_vertical_interval;

#define asn1SccBase_samples_DepthMap_vertical_interval_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_DepthMap_vertical_interval_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_DepthMap_vertical_interval_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_DepthMap_vertical_interval_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_DepthMap_vertical_interval_REQUIRED_BYTES_FOR_XER_ENCODING   14283

void asn1SccBase_samples_DepthMap_vertical_interval_Initialize(asn1SccBase_samples_DepthMap_vertical_interval* pVal);
flag asn1SccBase_samples_DepthMap_vertical_interval_IsConstraintValid(const asn1SccBase_samples_DepthMap_vertical_interval* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_vertical_interval 
#define ERR_asn1SccBase_samples_DepthMap_vertical_interval		1047  /*(SIZE(1 .. numBase-samples-DepthMap-vertical-interval))*/
#endif

typedef double asn1SccT_Float;

#define asn1SccT_Float_REQUIRED_BYTES_FOR_ENCODING       13 
#define asn1SccT_Float_REQUIRED_BITS_FOR_ENCODING        104
#define asn1SccT_Float_REQUIRED_BYTES_FOR_ACN_ENCODING   13 
#define asn1SccT_Float_REQUIRED_BITS_FOR_ACN_ENCODING    104
#define asn1SccT_Float_REQUIRED_BYTES_FOR_XER_ENCODING   69

void asn1SccT_Float_Initialize(asn1SccT_Float* pVal);
flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* val, int* pErrCode);
#ifndef ERR_asn1SccT_Float 
#define ERR_asn1SccT_Float		1048  /*(-3.40282346600000020000E+038 .. 3.40282346600000020000E+038)*/
#endif

typedef struct {
    asn1SccT_Double position;
    asn1SccT_Float speed;
    asn1SccT_Float effort;
    asn1SccT_Float raw;
    asn1SccT_Float acceleration;
} asn1SccBase_JointState;

#define asn1SccBase_JointState_REQUIRED_BYTES_FOR_ENCODING       65 
#define asn1SccBase_JointState_REQUIRED_BITS_FOR_ENCODING        520
#define asn1SccBase_JointState_REQUIRED_BYTES_FOR_ACN_ENCODING   65 
#define asn1SccBase_JointState_REQUIRED_BITS_FOR_ACN_ENCODING    520
#define asn1SccBase_JointState_REQUIRED_BYTES_FOR_XER_ENCODING   378

void asn1SccBase_JointState_Initialize(asn1SccBase_JointState* pVal);
flag asn1SccBase_JointState_IsConstraintValid(const asn1SccBase_JointState* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_JointState arr[200];
} asn1SccBase_JointTrajectory;

#define asn1SccBase_JointTrajectory_REQUIRED_BYTES_FOR_ENCODING       13001 
#define asn1SccBase_JointTrajectory_REQUIRED_BITS_FOR_ENCODING        104008
#define asn1SccBase_JointTrajectory_REQUIRED_BYTES_FOR_ACN_ENCODING   13001 
#define asn1SccBase_JointTrajectory_REQUIRED_BITS_FOR_ACN_ENCODING    104008
#define asn1SccBase_JointTrajectory_REQUIRED_BYTES_FOR_XER_ENCODING   75645

void asn1SccBase_JointTrajectory_Initialize(asn1SccBase_JointTrajectory* pVal);
flag asn1SccBase_JointTrajectory_IsConstraintValid(const asn1SccBase_JointTrajectory* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointTrajectory 
#define ERR_asn1SccBase_JointTrajectory		1049  /*(SIZE(1 .. numBase-JointTrajectory))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_JointTrajectory arr[200];
} asn1SccBase_NamedVector_Base_JointTrajectory_elements;

#define asn1SccBase_NamedVector_Base_JointTrajectory_elements_REQUIRED_BYTES_FOR_ENCODING       2600201 
#define asn1SccBase_NamedVector_Base_JointTrajectory_elements_REQUIRED_BITS_FOR_ENCODING        20801608
#define asn1SccBase_NamedVector_Base_JointTrajectory_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   2600201 
#define asn1SccBase_NamedVector_Base_JointTrajectory_elements_REQUIRED_BITS_FOR_ACN_ENCODING    20801608
#define asn1SccBase_NamedVector_Base_JointTrajectory_elements_REQUIRED_BYTES_FOR_XER_ENCODING   15129097

void asn1SccBase_NamedVector_Base_JointTrajectory_elements_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal);
flag asn1SccBase_NamedVector_Base_JointTrajectory_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointTrajectory_elements 
#define ERR_asn1SccBase_NamedVector_Base_JointTrajectory_elements		1050  /*(SIZE(1 .. numBase-NamedVector-Base-JointTrajectory-elements))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_JointTrajectory arr[200];
} asn1SccBase_JointsTrajectory_elements;

#define asn1SccBase_JointsTrajectory_elements_REQUIRED_BYTES_FOR_ENCODING       2600201 
#define asn1SccBase_JointsTrajectory_elements_REQUIRED_BITS_FOR_ENCODING        20801608
#define asn1SccBase_JointsTrajectory_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   2600201 
#define asn1SccBase_JointsTrajectory_elements_REQUIRED_BITS_FOR_ACN_ENCODING    20801608
#define asn1SccBase_JointsTrajectory_elements_REQUIRED_BYTES_FOR_XER_ENCODING   15129065

void asn1SccBase_JointsTrajectory_elements_Initialize(asn1SccBase_JointsTrajectory_elements* pVal);
flag asn1SccBase_JointsTrajectory_elements_IsConstraintValid(const asn1SccBase_JointsTrajectory_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointsTrajectory_elements 
#define ERR_asn1SccBase_JointsTrajectory_elements		1051  /*(SIZE(1 .. numBase-JointsTrajectory-elements))*/
#endif

typedef struct {
    asn1SccBase_JointState min;
    asn1SccBase_JointState max;
} asn1SccBase_JointLimitRange;

#define asn1SccBase_JointLimitRange_REQUIRED_BYTES_FOR_ENCODING       130 
#define asn1SccBase_JointLimitRange_REQUIRED_BITS_FOR_ENCODING        1040
#define asn1SccBase_JointLimitRange_REQUIRED_BYTES_FOR_ACN_ENCODING   130 
#define asn1SccBase_JointLimitRange_REQUIRED_BITS_FOR_ACN_ENCODING    1040
#define asn1SccBase_JointLimitRange_REQUIRED_BYTES_FOR_XER_ENCODING   753

void asn1SccBase_JointLimitRange_Initialize(asn1SccBase_JointLimitRange* pVal);
flag asn1SccBase_JointLimitRange_IsConstraintValid(const asn1SccBase_JointLimitRange* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_JointLimitRange arr[200];
} asn1SccBase_NamedVector_Base_JointLimitRange_elements;

#define asn1SccBase_NamedVector_Base_JointLimitRange_elements_REQUIRED_BYTES_FOR_ENCODING       26001 
#define asn1SccBase_NamedVector_Base_JointLimitRange_elements_REQUIRED_BITS_FOR_ENCODING        208008
#define asn1SccBase_NamedVector_Base_JointLimitRange_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   26001 
#define asn1SccBase_NamedVector_Base_JointLimitRange_elements_REQUIRED_BITS_FOR_ACN_ENCODING    208008
#define asn1SccBase_NamedVector_Base_JointLimitRange_elements_REQUIRED_BYTES_FOR_XER_ENCODING   150697

void asn1SccBase_NamedVector_Base_JointLimitRange_elements_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal);
flag asn1SccBase_NamedVector_Base_JointLimitRange_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointLimitRange_elements 
#define ERR_asn1SccBase_NamedVector_Base_JointLimitRange_elements		1052  /*(SIZE(1 .. numBase-NamedVector-Base-JointLimitRange-elements))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_JointLimitRange arr[200];
} asn1SccBase_JointLimits_elements;

#define asn1SccBase_JointLimits_elements_REQUIRED_BYTES_FOR_ENCODING       26001 
#define asn1SccBase_JointLimits_elements_REQUIRED_BITS_FOR_ENCODING        208008
#define asn1SccBase_JointLimits_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   26001 
#define asn1SccBase_JointLimits_elements_REQUIRED_BITS_FOR_ACN_ENCODING    208008
#define asn1SccBase_JointLimits_elements_REQUIRED_BYTES_FOR_XER_ENCODING   150655

void asn1SccBase_JointLimits_elements_Initialize(asn1SccBase_JointLimits_elements* pVal);
flag asn1SccBase_JointLimits_elements_IsConstraintValid(const asn1SccBase_JointLimits_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointLimits_elements 
#define ERR_asn1SccBase_JointLimits_elements		1053  /*(SIZE(1 .. numBase-JointLimits-elements))*/
#endif

typedef struct {
    asn1SccT_Float pascal;
} asn1SccBase_Pressure;

#define asn1SccBase_Pressure_REQUIRED_BYTES_FOR_ENCODING       13 
#define asn1SccBase_Pressure_REQUIRED_BITS_FOR_ENCODING        104
#define asn1SccBase_Pressure_REQUIRED_BYTES_FOR_ACN_ENCODING   13 
#define asn1SccBase_Pressure_REQUIRED_BITS_FOR_ACN_ENCODING    104
#define asn1SccBase_Pressure_REQUIRED_BYTES_FOR_XER_ENCODING   98

void asn1SccBase_Pressure_Initialize(asn1SccBase_Pressure* pVal);
flag asn1SccBase_Pressure_IsConstraintValid(const asn1SccBase_Pressure* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_Float arr[200];
} asn1SccBase_samples_Sonar_bins;

#define asn1SccBase_samples_Sonar_bins_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_Sonar_bins_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_Sonar_bins_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_Sonar_bins_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_Sonar_bins_REQUIRED_BYTES_FOR_XER_ENCODING   13851

void asn1SccBase_samples_Sonar_bins_Initialize(asn1SccBase_samples_Sonar_bins* pVal);
flag asn1SccBase_samples_Sonar_bins_IsConstraintValid(const asn1SccBase_samples_Sonar_bins* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Sonar_bins 
#define ERR_asn1SccBase_samples_Sonar_bins		1054  /*(SIZE(1 .. numBase-samples-Sonar-bins))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Float arr[200];
} asn1SccBase_samples_LaserScan_remission;

#define asn1SccBase_samples_LaserScan_remission_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_LaserScan_remission_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_LaserScan_remission_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_LaserScan_remission_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_LaserScan_remission_REQUIRED_BYTES_FOR_XER_ENCODING   13869

void asn1SccBase_samples_LaserScan_remission_Initialize(asn1SccBase_samples_LaserScan_remission* pVal);
flag asn1SccBase_samples_LaserScan_remission_IsConstraintValid(const asn1SccBase_samples_LaserScan_remission* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_LaserScan_remission 
#define ERR_asn1SccBase_samples_LaserScan_remission		1055  /*(SIZE(1 .. numBase-samples-LaserScan-remission))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Float arr[200];
} asn1SccBase_samples_DistanceImage_data;

#define asn1SccBase_samples_DistanceImage_data_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_DistanceImage_data_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_DistanceImage_data_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_DistanceImage_data_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_DistanceImage_data_REQUIRED_BYTES_FOR_XER_ENCODING   13867

void asn1SccBase_samples_DistanceImage_data_Initialize(asn1SccBase_samples_DistanceImage_data* pVal);
flag asn1SccBase_samples_DistanceImage_data_IsConstraintValid(const asn1SccBase_samples_DistanceImage_data* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DistanceImage_data 
#define ERR_asn1SccBase_samples_DistanceImage_data		1056  /*(SIZE(1 .. numBase-samples-DistanceImage-data))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Float arr[200];
} asn1SccBase_samples_DepthMap_remissions;

#define asn1SccBase_samples_DepthMap_remissions_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_DepthMap_remissions_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_DepthMap_remissions_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_DepthMap_remissions_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_DepthMap_remissions_REQUIRED_BYTES_FOR_XER_ENCODING   13869

void asn1SccBase_samples_DepthMap_remissions_Initialize(asn1SccBase_samples_DepthMap_remissions* pVal);
flag asn1SccBase_samples_DepthMap_remissions_IsConstraintValid(const asn1SccBase_samples_DepthMap_remissions* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_remissions 
#define ERR_asn1SccBase_samples_DepthMap_remissions		1057  /*(SIZE(1 .. numBase-samples-DepthMap-remissions))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_Float arr[200];
} asn1SccBase_samples_DepthMap_distances;

#define asn1SccBase_samples_DepthMap_distances_REQUIRED_BYTES_FOR_ENCODING       2601 
#define asn1SccBase_samples_DepthMap_distances_REQUIRED_BITS_FOR_ENCODING        20808
#define asn1SccBase_samples_DepthMap_distances_REQUIRED_BYTES_FOR_ACN_ENCODING   2601 
#define asn1SccBase_samples_DepthMap_distances_REQUIRED_BITS_FOR_ACN_ENCODING    20808
#define asn1SccBase_samples_DepthMap_distances_REQUIRED_BYTES_FOR_XER_ENCODING   13867

void asn1SccBase_samples_DepthMap_distances_Initialize(asn1SccBase_samples_DepthMap_distances* pVal);
flag asn1SccBase_samples_DepthMap_distances_IsConstraintValid(const asn1SccBase_samples_DepthMap_distances* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_distances 
#define ERR_asn1SccBase_samples_DepthMap_distances		1058  /*(SIZE(1 .. numBase-samples-DepthMap-distances))*/
#endif

typedef asn1SccSint asn1SccT_Int16;

#define asn1SccT_Int16_REQUIRED_BYTES_FOR_ENCODING       2 
#define asn1SccT_Int16_REQUIRED_BITS_FOR_ENCODING        16
#define asn1SccT_Int16_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define asn1SccT_Int16_REQUIRED_BITS_FOR_ACN_ENCODING    16
#define asn1SccT_Int16_REQUIRED_BYTES_FOR_XER_ENCODING   39

void asn1SccT_Int16_Initialize(asn1SccT_Int16* pVal);
flag asn1SccT_Int16_IsConstraintValid(const asn1SccT_Int16* val, int* pErrCode);
#ifndef ERR_asn1SccT_Int16 
#define ERR_asn1SccT_Int16		1059  /*(-32768 .. 32767)*/
#endif

typedef asn1SccUint asn1SccT_UInt16;

#define asn1SccT_UInt16_REQUIRED_BYTES_FOR_ENCODING       2 
#define asn1SccT_UInt16_REQUIRED_BITS_FOR_ENCODING        16
#define asn1SccT_UInt16_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define asn1SccT_UInt16_REQUIRED_BITS_FOR_ACN_ENCODING    16
#define asn1SccT_UInt16_REQUIRED_BYTES_FOR_XER_ENCODING   41

void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal);
flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* val, int* pErrCode);
#ifndef ERR_asn1SccT_UInt16 
#define ERR_asn1SccT_UInt16		1060  /*(0 .. 65535)*/
#endif

typedef struct {
    asn1SccT_UInt16 width;
    asn1SccT_UInt16 height;
} asn1SccBase_samples_frame_frame_size_t;

#define asn1SccBase_samples_frame_frame_size_t_REQUIRED_BYTES_FOR_ENCODING       4 
#define asn1SccBase_samples_frame_frame_size_t_REQUIRED_BITS_FOR_ENCODING        32
#define asn1SccBase_samples_frame_frame_size_t_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define asn1SccBase_samples_frame_frame_size_t_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define asn1SccBase_samples_frame_frame_size_t_REQUIRED_BYTES_FOR_XER_ENCODING   139

void asn1SccBase_samples_frame_frame_size_t_Initialize(asn1SccBase_samples_frame_frame_size_t* pVal);
flag asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_size_t* val, int* pErrCode);


typedef asn1SccUint asn1SccT_UInt64;

#define asn1SccT_UInt64_REQUIRED_BYTES_FOR_ENCODING       8 
#define asn1SccT_UInt64_REQUIRED_BITS_FOR_ENCODING        63
#define asn1SccT_UInt64_REQUIRED_BYTES_FOR_ACN_ENCODING   8 
#define asn1SccT_UInt64_REQUIRED_BITS_FOR_ACN_ENCODING    63
#define asn1SccT_UInt64_REQUIRED_BYTES_FOR_XER_ENCODING   41

void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal);
flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* val, int* pErrCode);
#ifndef ERR_asn1SccT_UInt64 
#define ERR_asn1SccT_UInt64		1061  /*(0 .. 9223372036854775807)*/
#endif

typedef asn1SccSint asn1SccT_Int64;

#define asn1SccT_Int64_REQUIRED_BYTES_FOR_ENCODING       8 
#define asn1SccT_Int64_REQUIRED_BITS_FOR_ENCODING        64
#define asn1SccT_Int64_REQUIRED_BYTES_FOR_ACN_ENCODING   8 
#define asn1SccT_Int64_REQUIRED_BITS_FOR_ACN_ENCODING    64
#define asn1SccT_Int64_REQUIRED_BYTES_FOR_XER_ENCODING   39

void asn1SccT_Int64_Initialize(asn1SccT_Int64* pVal);
flag asn1SccT_Int64_IsConstraintValid(const asn1SccT_Int64* val, int* pErrCode);
#ifndef ERR_asn1SccT_Int64 
#define ERR_asn1SccT_Int64		1062  /*(-9223372036854775807 .. 9223372036854775807)*/
#endif

typedef struct {
    asn1SccT_Int64 microseconds;
} asn1SccBase_Time;

#define asn1SccBase_Time_REQUIRED_BYTES_FOR_ENCODING       8 
#define asn1SccBase_Time_REQUIRED_BITS_FOR_ENCODING        64
#define asn1SccBase_Time_REQUIRED_BYTES_FOR_ACN_ENCODING   8 
#define asn1SccBase_Time_REQUIRED_BITS_FOR_ACN_ENCODING    64
#define asn1SccBase_Time_REQUIRED_BYTES_FOR_XER_ENCODING   72

void asn1SccBase_Time_Initialize(asn1SccBase_Time* pVal);
flag asn1SccBase_Time_IsConstraintValid(const asn1SccBase_Time* val, int* pErrCode);


typedef struct {
    asn1SccT_Double translation;
    asn1SccT_Double rotation;
    asn1SccBase_Angle heading;
    asn1SccBase_Time time;
} asn1SccBase_TimeStamped_Base_commands_Motion2D;

#define asn1SccBase_TimeStamped_Base_commands_Motion2D_REQUIRED_BYTES_FOR_ENCODING       47 
#define asn1SccBase_TimeStamped_Base_commands_Motion2D_REQUIRED_BITS_FOR_ENCODING        376
#define asn1SccBase_TimeStamped_Base_commands_Motion2D_REQUIRED_BYTES_FOR_ACN_ENCODING   47 
#define asn1SccBase_TimeStamped_Base_commands_Motion2D_REQUIRED_BITS_FOR_ACN_ENCODING    376
#define asn1SccBase_TimeStamped_Base_commands_Motion2D_REQUIRED_BYTES_FOR_XER_ENCODING   373

void asn1SccBase_TimeStamped_Base_commands_Motion2D_Initialize(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal);
flag asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const asn1SccBase_TimeStamped_Base_commands_Motion2D* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccWrappers_Vector3d linear;
    asn1SccWrappers_Vector3d angular;
} asn1SccBase_LinearAngular6DCommand;

#define asn1SccBase_LinearAngular6DCommand_REQUIRED_BYTES_FOR_ENCODING       87 
#define asn1SccBase_LinearAngular6DCommand_REQUIRED_BITS_FOR_ENCODING        692
#define asn1SccBase_LinearAngular6DCommand_REQUIRED_BYTES_FOR_ACN_ENCODING   87 
#define asn1SccBase_LinearAngular6DCommand_REQUIRED_BITS_FOR_ACN_ENCODING    692
#define asn1SccBase_LinearAngular6DCommand_REQUIRED_BYTES_FOR_XER_ENCODING   609

void asn1SccBase_LinearAngular6DCommand_Initialize(asn1SccBase_LinearAngular6DCommand* pVal);
flag asn1SccBase_LinearAngular6DCommand_IsConstraintValid(const asn1SccBase_LinearAngular6DCommand* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_TransformWithCovariance pose;
    asn1SccBase_TwistWithCovariance velocity;
} asn1SccBase_samples_BodyState;

#define asn1SccBase_samples_BodyState_REQUIRED_BYTES_FOR_ENCODING       1116 
#define asn1SccBase_samples_BodyState_REQUIRED_BITS_FOR_ENCODING        8924
#define asn1SccBase_samples_BodyState_REQUIRED_BYTES_FOR_ACN_ENCODING   1116 
#define asn1SccBase_samples_BodyState_REQUIRED_BITS_FOR_ACN_ENCODING    8924
#define asn1SccBase_samples_BodyState_REQUIRED_BYTES_FOR_XER_ENCODING   6340

void asn1SccBase_samples_BodyState_Initialize(asn1SccBase_samples_BodyState* pVal);
flag asn1SccBase_samples_BodyState_IsConstraintValid(const asn1SccBase_samples_BodyState* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccWrappers_Vector3d acc;
    asn1SccWrappers_Vector3d gyro;
    asn1SccWrappers_Vector3d mag;
} asn1SccBase_samples_IMUSensors;

#define asn1SccBase_samples_IMUSensors_REQUIRED_BYTES_FOR_ENCODING       126 
#define asn1SccBase_samples_IMUSensors_REQUIRED_BITS_FOR_ENCODING        1006
#define asn1SccBase_samples_IMUSensors_REQUIRED_BYTES_FOR_ACN_ENCODING   126 
#define asn1SccBase_samples_IMUSensors_REQUIRED_BITS_FOR_ACN_ENCODING    1006
#define asn1SccBase_samples_IMUSensors_REQUIRED_BYTES_FOR_XER_ENCODING   826

void asn1SccBase_samples_IMUSensors_Initialize(asn1SccBase_samples_IMUSensors* pVal);
flag asn1SccBase_samples_IMUSensors_IsConstraintValid(const asn1SccBase_samples_IMUSensors* val, int* pErrCode);


typedef struct {
    asn1SccT_Double translation;
    asn1SccT_Double rotation;
    asn1SccBase_Angle heading;
    asn1SccBase_Time time;
} asn1SccBase_samples_Motion2D;

#define asn1SccBase_samples_Motion2D_REQUIRED_BYTES_FOR_ENCODING       47 
#define asn1SccBase_samples_Motion2D_REQUIRED_BITS_FOR_ENCODING        376
#define asn1SccBase_samples_Motion2D_REQUIRED_BYTES_FOR_ACN_ENCODING   47 
#define asn1SccBase_samples_Motion2D_REQUIRED_BITS_FOR_ACN_ENCODING    376
#define asn1SccBase_samples_Motion2D_REQUIRED_BYTES_FOR_XER_ENCODING   337

void asn1SccBase_samples_Motion2D_Initialize(asn1SccBase_samples_Motion2D* pVal);
flag asn1SccBase_samples_Motion2D_IsConstraintValid(const asn1SccBase_samples_Motion2D* val, int* pErrCode);


typedef struct {
    asn1SccT_Float pascal;
    asn1SccBase_Time time;
} asn1SccBase_samples_Pressure;

#define asn1SccBase_samples_Pressure_REQUIRED_BYTES_FOR_ENCODING       21 
#define asn1SccBase_samples_Pressure_REQUIRED_BITS_FOR_ENCODING        168
#define asn1SccBase_samples_Pressure_REQUIRED_BYTES_FOR_ACN_ENCODING   21 
#define asn1SccBase_samples_Pressure_REQUIRED_BITS_FOR_ACN_ENCODING    168
#define asn1SccBase_samples_Pressure_REQUIRED_BYTES_FOR_XER_ENCODING   176

void asn1SccBase_samples_Pressure_Initialize(asn1SccBase_samples_Pressure* pVal);
flag asn1SccBase_samples_Pressure_IsConstraintValid(const asn1SccBase_samples_Pressure* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccWrappers_Vector3d acceleration;
    asn1SccWrappers_Matrix3d cov_acceleration;
    asn1SccWrappers_Vector3d angular_acceleration;
    asn1SccWrappers_Matrix3d cov_angular_acceleration;
} asn1SccBase_samples_RigidBodyAcceleration;

#define asn1SccBase_samples_RigidBodyAcceleration_REQUIRED_BYTES_FOR_ENCODING       322 
#define asn1SccBase_samples_RigidBodyAcceleration_REQUIRED_BITS_FOR_ENCODING        2572
#define asn1SccBase_samples_RigidBodyAcceleration_REQUIRED_BYTES_FOR_ACN_ENCODING   322 
#define asn1SccBase_samples_RigidBodyAcceleration_REQUIRED_BITS_FOR_ACN_ENCODING    2572
#define asn1SccBase_samples_RigidBodyAcceleration_REQUIRED_BYTES_FOR_XER_ENCODING   2055

void asn1SccBase_samples_RigidBodyAcceleration_Initialize(asn1SccBase_samples_RigidBodyAcceleration* pVal);
flag asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d force;
    asn1SccWrappers_Vector3d torque;
    asn1SccBase_Time time;
} asn1SccBase_samples_Wrench;

#define asn1SccBase_samples_Wrench_REQUIRED_BYTES_FOR_ENCODING       87 
#define asn1SccBase_samples_Wrench_REQUIRED_BITS_FOR_ENCODING        692
#define asn1SccBase_samples_Wrench_REQUIRED_BYTES_FOR_ACN_ENCODING   87 
#define asn1SccBase_samples_Wrench_REQUIRED_BITS_FOR_ACN_ENCODING    692
#define asn1SccBase_samples_Wrench_REQUIRED_BYTES_FOR_XER_ENCODING   589

void asn1SccBase_samples_Wrench_Initialize(asn1SccBase_samples_Wrench* pVal);
flag asn1SccBase_samples_Wrench_IsConstraintValid(const asn1SccBase_samples_Wrench* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccT_UInt16 width;
    asn1SccT_UInt16 height;
    asn1SccT_Float scale_x;
    asn1SccT_Float scale_y;
    asn1SccT_Float center_x;
    asn1SccT_Float center_y;
    asn1SccBase_samples_DistanceImage_data data;
} asn1SccBase_samples_DistanceImage;

#define asn1SccBase_samples_DistanceImage_REQUIRED_BYTES_FOR_ENCODING       2665 
#define asn1SccBase_samples_DistanceImage_REQUIRED_BITS_FOR_ENCODING        21320
#define asn1SccBase_samples_DistanceImage_REQUIRED_BYTES_FOR_ACN_ENCODING   2665 
#define asn1SccBase_samples_DistanceImage_REQUIRED_BITS_FOR_ACN_ENCODING    21320
#define asn1SccBase_samples_DistanceImage_REQUIRED_BYTES_FOR_XER_ENCODING   14284

void asn1SccBase_samples_DistanceImage_Initialize(asn1SccBase_samples_DistanceImage* pVal);
flag asn1SccBase_samples_DistanceImage_IsConstraintValid(const asn1SccBase_samples_DistanceImage* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_samples_Pointcloud_points points;
    asn1SccBase_samples_Pointcloud_colors colors;
} asn1SccBase_samples_Pointcloud;

#define asn1SccBase_samples_Pointcloud_REQUIRED_BYTES_FOR_ENCODING       18310 
#define asn1SccBase_samples_Pointcloud_REQUIRED_BITS_FOR_ENCODING        146480
#define asn1SccBase_samples_Pointcloud_REQUIRED_BYTES_FOR_ACN_ENCODING   18310 
#define asn1SccBase_samples_Pointcloud_REQUIRED_BITS_FOR_ACN_ENCODING    146480
#define asn1SccBase_samples_Pointcloud_REQUIRED_BYTES_FOR_XER_ENCODING   120347

void asn1SccBase_samples_Pointcloud_Initialize(asn1SccBase_samples_Pointcloud* pVal);
flag asn1SccBase_samples_Pointcloud_IsConstraintValid(const asn1SccBase_samples_Pointcloud* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccWrappers_Vector3d linear;
    asn1SccWrappers_Vector3d angular;
} asn1SccBase_commands_LinearAngular6DCommand_m;

#define asn1SccBase_commands_LinearAngular6DCommand_m_REQUIRED_BYTES_FOR_ENCODING       87 
#define asn1SccBase_commands_LinearAngular6DCommand_m_REQUIRED_BITS_FOR_ENCODING        692
#define asn1SccBase_commands_LinearAngular6DCommand_m_REQUIRED_BYTES_FOR_ACN_ENCODING   87 
#define asn1SccBase_commands_LinearAngular6DCommand_m_REQUIRED_BITS_FOR_ACN_ENCODING    692
#define asn1SccBase_commands_LinearAngular6DCommand_m_REQUIRED_BYTES_FOR_XER_ENCODING   631

void asn1SccBase_commands_LinearAngular6DCommand_m_Initialize(asn1SccBase_commands_LinearAngular6DCommand_m* pVal);
flag asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(const asn1SccBase_commands_LinearAngular6DCommand_m* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_TransformWithCovariance_m pose;
    asn1SccBase_TwistWithCovariance_m velocity;
} asn1SccBase_samples_BodyState_m;

#define asn1SccBase_samples_BodyState_m_REQUIRED_BYTES_FOR_ENCODING       1116 
#define asn1SccBase_samples_BodyState_m_REQUIRED_BITS_FOR_ENCODING        8924
#define asn1SccBase_samples_BodyState_m_REQUIRED_BYTES_FOR_ACN_ENCODING   1116 
#define asn1SccBase_samples_BodyState_m_REQUIRED_BITS_FOR_ACN_ENCODING    8924
#define asn1SccBase_samples_BodyState_m_REQUIRED_BYTES_FOR_XER_ENCODING   6344

void asn1SccBase_samples_BodyState_m_Initialize(asn1SccBase_samples_BodyState_m* pVal);
flag asn1SccBase_samples_BodyState_m_IsConstraintValid(const asn1SccBase_samples_BodyState_m* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccWrappers_Vector3d acc;
    asn1SccWrappers_Vector3d gyro;
    asn1SccWrappers_Vector3d mag;
} asn1SccBase_samples_IMUSensors_m;

#define asn1SccBase_samples_IMUSensors_m_REQUIRED_BYTES_FOR_ENCODING       126 
#define asn1SccBase_samples_IMUSensors_m_REQUIRED_BITS_FOR_ENCODING        1006
#define asn1SccBase_samples_IMUSensors_m_REQUIRED_BYTES_FOR_ACN_ENCODING   126 
#define asn1SccBase_samples_IMUSensors_m_REQUIRED_BITS_FOR_ACN_ENCODING    1006
#define asn1SccBase_samples_IMUSensors_m_REQUIRED_BYTES_FOR_XER_ENCODING   830

void asn1SccBase_samples_IMUSensors_m_Initialize(asn1SccBase_samples_IMUSensors_m* pVal);
flag asn1SccBase_samples_IMUSensors_m_IsConstraintValid(const asn1SccBase_samples_IMUSensors_m* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccWrappers_Vector3d acceleration;
    asn1SccWrappers_Matrix3d cov_acceleration;
    asn1SccWrappers_Vector3d angular_acceleration;
    asn1SccWrappers_Matrix3d cov_angular_acceleration;
} asn1SccBase_samples_RigidBodyAcceleration_m;

#define asn1SccBase_samples_RigidBodyAcceleration_m_REQUIRED_BYTES_FOR_ENCODING       322 
#define asn1SccBase_samples_RigidBodyAcceleration_m_REQUIRED_BITS_FOR_ENCODING        2572
#define asn1SccBase_samples_RigidBodyAcceleration_m_REQUIRED_BYTES_FOR_ACN_ENCODING   322 
#define asn1SccBase_samples_RigidBodyAcceleration_m_REQUIRED_BITS_FOR_ACN_ENCODING    2572
#define asn1SccBase_samples_RigidBodyAcceleration_m_REQUIRED_BYTES_FOR_XER_ENCODING   2059

void asn1SccBase_samples_RigidBodyAcceleration_m_Initialize(asn1SccBase_samples_RigidBodyAcceleration_m* pVal);
flag asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration_m* val, int* pErrCode);


typedef struct {
    asn1SccWrappers_Vector3d force;
    asn1SccWrappers_Vector3d torque;
    asn1SccBase_Time time;
} asn1SccBase_samples_Wrench_m;

#define asn1SccBase_samples_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       87 
#define asn1SccBase_samples_Wrench_m_REQUIRED_BITS_FOR_ENCODING        692
#define asn1SccBase_samples_Wrench_m_REQUIRED_BYTES_FOR_ACN_ENCODING   87 
#define asn1SccBase_samples_Wrench_m_REQUIRED_BITS_FOR_ACN_ENCODING    692
#define asn1SccBase_samples_Wrench_m_REQUIRED_BYTES_FOR_XER_ENCODING   593

void asn1SccBase_samples_Wrench_m_Initialize(asn1SccBase_samples_Wrench_m* pVal);
flag asn1SccBase_samples_Wrench_m_IsConstraintValid(const asn1SccBase_samples_Wrench_m* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_samples_Pointcloud_m_points points;
    asn1SccBase_samples_Pointcloud_m_colors colors;
} asn1SccBase_samples_Pointcloud_m;

#define asn1SccBase_samples_Pointcloud_m_REQUIRED_BYTES_FOR_ENCODING       18310 
#define asn1SccBase_samples_Pointcloud_m_REQUIRED_BITS_FOR_ENCODING        146480
#define asn1SccBase_samples_Pointcloud_m_REQUIRED_BYTES_FOR_ACN_ENCODING   18310 
#define asn1SccBase_samples_Pointcloud_m_REQUIRED_BITS_FOR_ACN_ENCODING    146480
#define asn1SccBase_samples_Pointcloud_m_REQUIRED_BYTES_FOR_XER_ENCODING   120351

void asn1SccBase_samples_Pointcloud_m_Initialize(asn1SccBase_samples_Pointcloud_m* pVal);
flag asn1SccBase_samples_Pointcloud_m_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_Time arr[200];
} asn1SccBase_samples_SonarScan_time_beams;

#define asn1SccBase_samples_SonarScan_time_beams_REQUIRED_BYTES_FOR_ENCODING       1601 
#define asn1SccBase_samples_SonarScan_time_beams_REQUIRED_BITS_FOR_ENCODING        12808
#define asn1SccBase_samples_SonarScan_time_beams_REQUIRED_BYTES_FOR_ACN_ENCODING   1601 
#define asn1SccBase_samples_SonarScan_time_beams_REQUIRED_BITS_FOR_ACN_ENCODING    12808
#define asn1SccBase_samples_SonarScan_time_beams_REQUIRED_BYTES_FOR_XER_ENCODING   14471

void asn1SccBase_samples_SonarScan_time_beams_Initialize(asn1SccBase_samples_SonarScan_time_beams* pVal);
flag asn1SccBase_samples_SonarScan_time_beams_IsConstraintValid(const asn1SccBase_samples_SonarScan_time_beams* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_SonarScan_time_beams 
#define ERR_asn1SccBase_samples_SonarScan_time_beams		1063  /*(SIZE(1 .. numBase-samples-SonarScan-time-beams))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_Time arr[200];
} asn1SccBase_samples_Sonar_timestamps;

#define asn1SccBase_samples_Sonar_timestamps_REQUIRED_BYTES_FOR_ENCODING       1601 
#define asn1SccBase_samples_Sonar_timestamps_REQUIRED_BITS_FOR_ENCODING        12808
#define asn1SccBase_samples_Sonar_timestamps_REQUIRED_BYTES_FOR_ACN_ENCODING   1601 
#define asn1SccBase_samples_Sonar_timestamps_REQUIRED_BITS_FOR_ACN_ENCODING    12808
#define asn1SccBase_samples_Sonar_timestamps_REQUIRED_BYTES_FOR_XER_ENCODING   14463

void asn1SccBase_samples_Sonar_timestamps_Initialize(asn1SccBase_samples_Sonar_timestamps* pVal);
flag asn1SccBase_samples_Sonar_timestamps_IsConstraintValid(const asn1SccBase_samples_Sonar_timestamps* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Sonar_timestamps 
#define ERR_asn1SccBase_samples_Sonar_timestamps		1064  /*(SIZE(1 .. numBase-samples-Sonar-timestamps))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_Time arr[200];
} asn1SccBase_samples_DepthMap_timestamps;

#define asn1SccBase_samples_DepthMap_timestamps_REQUIRED_BYTES_FOR_ENCODING       1601 
#define asn1SccBase_samples_DepthMap_timestamps_REQUIRED_BITS_FOR_ENCODING        12808
#define asn1SccBase_samples_DepthMap_timestamps_REQUIRED_BYTES_FOR_ACN_ENCODING   1601 
#define asn1SccBase_samples_DepthMap_timestamps_REQUIRED_BITS_FOR_ACN_ENCODING    12808
#define asn1SccBase_samples_DepthMap_timestamps_REQUIRED_BYTES_FOR_XER_ENCODING   14469

void asn1SccBase_samples_DepthMap_timestamps_Initialize(asn1SccBase_samples_DepthMap_timestamps* pVal);
flag asn1SccBase_samples_DepthMap_timestamps_IsConstraintValid(const asn1SccBase_samples_DepthMap_timestamps* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_DepthMap_timestamps 
#define ERR_asn1SccBase_samples_DepthMap_timestamps		1065  /*(SIZE(1 .. numBase-samples-DepthMap-timestamps))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_Time arr[200];
} asn1SccBase_JointsTrajectory_times_t;

#define asn1SccBase_JointsTrajectory_times_t_REQUIRED_BYTES_FOR_ENCODING       1601 
#define asn1SccBase_JointsTrajectory_times_t_REQUIRED_BITS_FOR_ENCODING        12808
#define asn1SccBase_JointsTrajectory_times_t_REQUIRED_BYTES_FOR_ACN_ENCODING   1601 
#define asn1SccBase_JointsTrajectory_times_t_REQUIRED_BITS_FOR_ACN_ENCODING    12808
#define asn1SccBase_JointsTrajectory_times_t_REQUIRED_BYTES_FOR_XER_ENCODING   14463

void asn1SccBase_JointsTrajectory_times_t_Initialize(asn1SccBase_JointsTrajectory_times_t* pVal);
flag asn1SccBase_JointsTrajectory_times_t_IsConstraintValid(const asn1SccBase_JointsTrajectory_times_t* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointsTrajectory_times_t 
#define ERR_asn1SccBase_JointsTrajectory_times_t		1066  /*(SIZE(1 .. numBase-JointsTrajectory-times-t))*/
#endif

typedef struct {    int nCount; 
    
    byte arr[200];
} asn1SccT_String;

#define asn1SccT_String_REQUIRED_BYTES_FOR_ENCODING       201 
#define asn1SccT_String_REQUIRED_BITS_FOR_ENCODING        1608
#define asn1SccT_String_REQUIRED_BYTES_FOR_ACN_ENCODING   201 
#define asn1SccT_String_REQUIRED_BITS_FOR_ACN_ENCODING    1608
#define asn1SccT_String_REQUIRED_BYTES_FOR_XER_ENCODING   421

void asn1SccT_String_Initialize(asn1SccT_String* pVal);
flag asn1SccT_String_IsConstraintValid(const asn1SccT_String* val, int* pErrCode);
#ifndef ERR_asn1SccT_String 
#define ERR_asn1SccT_String		1067  /*(SIZE(0 .. numT-String))*/
#endif

typedef struct {
    asn1SccT_String sourceframe;
    asn1SccT_String targetframe;
    asn1SccWrappers_Vector3d rotationaxis;
} asn1SccBase_JointTransform;

#define asn1SccBase_JointTransform_REQUIRED_BYTES_FOR_ENCODING       442 
#define asn1SccBase_JointTransform_REQUIRED_BITS_FOR_ENCODING        3530
#define asn1SccBase_JointTransform_REQUIRED_BYTES_FOR_ACN_ENCODING   442 
#define asn1SccBase_JointTransform_REQUIRED_BITS_FOR_ACN_ENCODING    3530
#define asn1SccBase_JointTransform_REQUIRED_BYTES_FOR_XER_ENCODING   1152

void asn1SccBase_JointTransform_Initialize(asn1SccBase_JointTransform* pVal);
flag asn1SccBase_JointTransform_IsConstraintValid(const asn1SccBase_JointTransform* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_JointTransform arr[200];
} asn1SccBase_NamedVector_Base_JointTransform_elements;

#define asn1SccBase_NamedVector_Base_JointTransform_elements_REQUIRED_BYTES_FOR_ENCODING       88251 
#define asn1SccBase_NamedVector_Base_JointTransform_elements_REQUIRED_BITS_FOR_ENCODING        706008
#define asn1SccBase_NamedVector_Base_JointTransform_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   88251 
#define asn1SccBase_NamedVector_Base_JointTransform_elements_REQUIRED_BITS_FOR_ACN_ENCODING    706008
#define asn1SccBase_NamedVector_Base_JointTransform_elements_REQUIRED_BYTES_FOR_XER_ENCODING   230495

void asn1SccBase_NamedVector_Base_JointTransform_elements_Initialize(asn1SccBase_NamedVector_Base_JointTransform_elements* pVal);
flag asn1SccBase_NamedVector_Base_JointTransform_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointTransform_elements 
#define ERR_asn1SccBase_NamedVector_Base_JointTransform_elements		1068  /*(SIZE(1 .. numBase-NamedVector-Base-JointTransform-elements))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccBase_JointTransform arr[200];
} asn1SccBase_JointTransformVector_elements;

#define asn1SccBase_JointTransformVector_elements_REQUIRED_BYTES_FOR_ENCODING       88251 
#define asn1SccBase_JointTransformVector_elements_REQUIRED_BITS_FOR_ENCODING        706008
#define asn1SccBase_JointTransformVector_elements_REQUIRED_BYTES_FOR_ACN_ENCODING   88251 
#define asn1SccBase_JointTransformVector_elements_REQUIRED_BITS_FOR_ACN_ENCODING    706008
#define asn1SccBase_JointTransformVector_elements_REQUIRED_BYTES_FOR_XER_ENCODING   230473

void asn1SccBase_JointTransformVector_elements_Initialize(asn1SccBase_JointTransformVector_elements* pVal);
flag asn1SccBase_JointTransformVector_elements_IsConstraintValid(const asn1SccBase_JointTransformVector_elements* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointTransformVector_elements 
#define ERR_asn1SccBase_JointTransformVector_elements		1069  /*(SIZE(1 .. numBase-JointTransformVector-elements))*/
#endif

typedef struct {
    asn1SccBase_Time time;
    asn1SccT_String sourceframe;
    asn1SccT_String targetframe;
    asn1SccWrappers_Vector3d position;
    asn1SccWrappers_Matrix3d cov_position;
    asn1SccWrappers_Quaterniond orientation;
    asn1SccWrappers_Matrix3d cov_orientation;
    asn1SccWrappers_Vector3d velocity;
    asn1SccWrappers_Matrix3d cov_velocity;
    asn1SccWrappers_Vector3d angular_velocity;
    asn1SccWrappers_Matrix3d cov_angular_velocity;
} asn1SccBase_samples_RigidBodyState;

#define asn1SccBase_samples_RigidBodyState_REQUIRED_BYTES_FOR_ENCODING       1050 
#define asn1SccBase_samples_RigidBodyState_REQUIRED_BITS_FOR_ENCODING        8400
#define asn1SccBase_samples_RigidBodyState_REQUIRED_BYTES_FOR_ACN_ENCODING   1050 
#define asn1SccBase_samples_RigidBodyState_REQUIRED_BITS_FOR_ACN_ENCODING    8400
#define asn1SccBase_samples_RigidBodyState_REQUIRED_BYTES_FOR_XER_ENCODING   4786

void asn1SccBase_samples_RigidBodyState_Initialize(asn1SccBase_samples_RigidBodyState* pVal);
flag asn1SccBase_samples_RigidBodyState_IsConstraintValid(const asn1SccBase_samples_RigidBodyState* val, int* pErrCode);


typedef struct {
    asn1SccT_String data;
    asn1SccT_String name_t;
} asn1SccBase_samples_frame_frame_attrib_t;

#define asn1SccBase_samples_frame_frame_attrib_t_REQUIRED_BYTES_FOR_ENCODING       402 
#define asn1SccBase_samples_frame_frame_attrib_t_REQUIRED_BITS_FOR_ENCODING        3216
#define asn1SccBase_samples_frame_frame_attrib_t_REQUIRED_BYTES_FOR_ACN_ENCODING   402 
#define asn1SccBase_samples_frame_frame_attrib_t_REQUIRED_BITS_FOR_ACN_ENCODING    3216
#define asn1SccBase_samples_frame_frame_attrib_t_REQUIRED_BYTES_FOR_XER_ENCODING   901

void asn1SccBase_samples_frame_frame_attrib_t_Initialize(asn1SccBase_samples_frame_frame_attrib_t* pVal);
flag asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_attrib_t* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_samples_frame_frame_attrib_t arr[200];
} asn1SccBase_samples_frame_Frame_attributes;

#define asn1SccBase_samples_frame_Frame_attributes_REQUIRED_BYTES_FOR_ENCODING       80401 
#define asn1SccBase_samples_frame_Frame_attributes_REQUIRED_BITS_FOR_ENCODING        643208
#define asn1SccBase_samples_frame_Frame_attributes_REQUIRED_BYTES_FOR_ACN_ENCODING   80401 
#define asn1SccBase_samples_frame_Frame_attributes_REQUIRED_BITS_FOR_ACN_ENCODING    643208
#define asn1SccBase_samples_frame_Frame_attributes_REQUIRED_BYTES_FOR_XER_ENCODING   180275

void asn1SccBase_samples_frame_Frame_attributes_Initialize(asn1SccBase_samples_frame_Frame_attributes* pVal);
flag asn1SccBase_samples_frame_Frame_attributes_IsConstraintValid(const asn1SccBase_samples_frame_Frame_attributes* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_frame_Frame_attributes 
#define ERR_asn1SccBase_samples_frame_Frame_attributes		1070  /*(SIZE(1 .. numBase-samples-frame-Frame-attributes))*/
#endif

typedef struct {
    asn1SccT_String sourceframe;
    asn1SccT_String targetframe;
    asn1SccWrappers_Vector3d rotationaxis;
} asn1SccBase_JointTransform_m;

#define asn1SccBase_JointTransform_m_REQUIRED_BYTES_FOR_ENCODING       442 
#define asn1SccBase_JointTransform_m_REQUIRED_BITS_FOR_ENCODING        3530
#define asn1SccBase_JointTransform_m_REQUIRED_BYTES_FOR_ACN_ENCODING   442 
#define asn1SccBase_JointTransform_m_REQUIRED_BITS_FOR_ACN_ENCODING    3530
#define asn1SccBase_JointTransform_m_REQUIRED_BYTES_FOR_XER_ENCODING   1156

void asn1SccBase_JointTransform_m_Initialize(asn1SccBase_JointTransform_m* pVal);
flag asn1SccBase_JointTransform_m_IsConstraintValid(const asn1SccBase_JointTransform_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_JointTransform_m arr[200];
} asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform;

#define asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       88251 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BITS_FOR_ENCODING        706008
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BYTES_FOR_ACN_ENCODING   88251 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BITS_FOR_ACN_ENCODING    706008
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BYTES_FOR_XER_ENCODING   231317

void asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal);
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* val, int* pErrCode);
#ifndef ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform 
#define ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform		1071  /*(SIZE(1 .. numStd-orogen-typekits-mtype-std-vector-base-JointTransform))*/
#endif

typedef struct {
    asn1SccBase_Time time;
    asn1SccT_String sourceframe;
    asn1SccT_String targetframe;
    asn1SccWrappers_Vector3d position;
    asn1SccWrappers_Matrix3d cov_position;
    asn1SccWrappers_Quaterniond orientation;
    asn1SccWrappers_Matrix3d cov_orientation;
    asn1SccWrappers_Vector3d velocity;
    asn1SccWrappers_Matrix3d cov_velocity;
    asn1SccWrappers_Vector3d angular_velocity;
    asn1SccWrappers_Matrix3d cov_angular_velocity;
} asn1SccBase_samples_RigidBodyState_m;

#define asn1SccBase_samples_RigidBodyState_m_REQUIRED_BYTES_FOR_ENCODING       1050 
#define asn1SccBase_samples_RigidBodyState_m_REQUIRED_BITS_FOR_ENCODING        8400
#define asn1SccBase_samples_RigidBodyState_m_REQUIRED_BYTES_FOR_ACN_ENCODING   1050 
#define asn1SccBase_samples_RigidBodyState_m_REQUIRED_BITS_FOR_ACN_ENCODING    8400
#define asn1SccBase_samples_RigidBodyState_m_REQUIRED_BYTES_FOR_XER_ENCODING   4790

void asn1SccBase_samples_RigidBodyState_m_Initialize(asn1SccBase_samples_RigidBodyState_m* pVal);
flag asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyState_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_samples_Wrenches_m_names;

#define asn1SccBase_samples_Wrenches_m_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_samples_Wrenches_m_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_samples_Wrenches_m_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_samples_Wrenches_m_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_samples_Wrenches_m_names_REQUIRED_BYTES_FOR_XER_ENCODING   84263

void asn1SccBase_samples_Wrenches_m_names_Initialize(asn1SccBase_samples_Wrenches_m_names* pVal);
flag asn1SccBase_samples_Wrenches_m_names_IsConstraintValid(const asn1SccBase_samples_Wrenches_m_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Wrenches_m_names 
#define ERR_asn1SccBase_samples_Wrenches_m_names		1072  /*(SIZE(1 .. numBase-samples-Wrenches-m-names))*/
#endif

typedef struct {
    asn1SccBase_samples_Wrenches_m_names names;
    asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench elements;
    asn1SccBase_Time time;
} asn1SccBase_samples_Wrenches_m;

#define asn1SccBase_samples_Wrenches_m_REQUIRED_BYTES_FOR_ENCODING       55910 
#define asn1SccBase_samples_Wrenches_m_REQUIRED_BITS_FOR_ENCODING        447280
#define asn1SccBase_samples_Wrenches_m_REQUIRED_BYTES_FOR_ACN_ENCODING   55910 
#define asn1SccBase_samples_Wrenches_m_REQUIRED_BITS_FOR_ACN_ENCODING    447280
#define asn1SccBase_samples_Wrenches_m_REQUIRED_BYTES_FOR_XER_ENCODING   187349

void asn1SccBase_samples_Wrenches_m_Initialize(asn1SccBase_samples_Wrenches_m* pVal);
flag asn1SccBase_samples_Wrenches_m_IsConstraintValid(const asn1SccBase_samples_Wrenches_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_base_Wrench_m_names;

#define asn1SccBase_NamedVector_base_Wrench_m_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_base_Wrench_m_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_base_Wrench_m_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_base_Wrench_m_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_base_Wrench_m_names_REQUIRED_BYTES_FOR_XER_ENCODING   84277

void asn1SccBase_NamedVector_base_Wrench_m_names_Initialize(asn1SccBase_NamedVector_base_Wrench_m_names* pVal);
flag asn1SccBase_NamedVector_base_Wrench_m_names_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_base_Wrench_m_names 
#define ERR_asn1SccBase_NamedVector_base_Wrench_m_names		1073  /*(SIZE(1 .. numBase-NamedVector-base-Wrench-m-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_base_Wrench_m_names names;
    asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench elements;
} asn1SccBase_NamedVector_base_Wrench_m;

#define asn1SccBase_NamedVector_base_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       55902 
#define asn1SccBase_NamedVector_base_Wrench_m_REQUIRED_BITS_FOR_ENCODING        447216
#define asn1SccBase_NamedVector_base_Wrench_m_REQUIRED_BYTES_FOR_ACN_ENCODING   55902 
#define asn1SccBase_NamedVector_base_Wrench_m_REQUIRED_BITS_FOR_ACN_ENCODING    447216
#define asn1SccBase_NamedVector_base_Wrench_m_REQUIRED_BYTES_FOR_XER_ENCODING   187301

void asn1SccBase_NamedVector_base_Wrench_m_Initialize(asn1SccBase_NamedVector_base_Wrench_m* pVal);
flag asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_base_JointTransform_m_names;

#define asn1SccBase_NamedVector_base_JointTransform_m_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_base_JointTransform_m_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_base_JointTransform_m_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_base_JointTransform_m_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_base_JointTransform_m_names_REQUIRED_BYTES_FOR_XER_ENCODING   84293

void asn1SccBase_NamedVector_base_JointTransform_m_names_Initialize(asn1SccBase_NamedVector_base_JointTransform_m_names* pVal);
flag asn1SccBase_NamedVector_base_JointTransform_m_names_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_base_JointTransform_m_names 
#define ERR_asn1SccBase_NamedVector_base_JointTransform_m_names		1074  /*(SIZE(1 .. numBase-NamedVector-base-JointTransform-m-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_base_JointTransform_m_names names;
    asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform elements;
} asn1SccBase_NamedVector_base_JointTransform_m;

#define asn1SccBase_NamedVector_base_JointTransform_m_REQUIRED_BYTES_FOR_ENCODING       128452 
#define asn1SccBase_NamedVector_base_JointTransform_m_REQUIRED_BITS_FOR_ENCODING        1027616
#define asn1SccBase_NamedVector_base_JointTransform_m_REQUIRED_BYTES_FOR_ACN_ENCODING   128452 
#define asn1SccBase_NamedVector_base_JointTransform_m_REQUIRED_BITS_FOR_ACN_ENCODING    1027616
#define asn1SccBase_NamedVector_base_JointTransform_m_REQUIRED_BYTES_FOR_XER_ENCODING   315517

void asn1SccBase_NamedVector_base_JointTransform_m_Initialize(asn1SccBase_NamedVector_base_JointTransform_m* pVal);
flag asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_JointTransformVector_m_names;

#define asn1SccBase_JointTransformVector_m_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_JointTransformVector_m_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_JointTransformVector_m_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_JointTransformVector_m_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_JointTransformVector_m_names_REQUIRED_BYTES_FOR_XER_ENCODING   84271

void asn1SccBase_JointTransformVector_m_names_Initialize(asn1SccBase_JointTransformVector_m_names* pVal);
flag asn1SccBase_JointTransformVector_m_names_IsConstraintValid(const asn1SccBase_JointTransformVector_m_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointTransformVector_m_names 
#define ERR_asn1SccBase_JointTransformVector_m_names		1075  /*(SIZE(1 .. numBase-JointTransformVector-m-names))*/
#endif

typedef struct {
    asn1SccBase_JointTransformVector_m_names names;
    asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform elements;
} asn1SccBase_JointTransformVector_m;

#define asn1SccBase_JointTransformVector_m_REQUIRED_BYTES_FOR_ENCODING       128452 
#define asn1SccBase_JointTransformVector_m_REQUIRED_BITS_FOR_ENCODING        1027616
#define asn1SccBase_JointTransformVector_m_REQUIRED_BYTES_FOR_ACN_ENCODING   128452 
#define asn1SccBase_JointTransformVector_m_REQUIRED_BITS_FOR_ACN_ENCODING    1027616
#define asn1SccBase_JointTransformVector_m_REQUIRED_BYTES_FOR_XER_ENCODING   315495

void asn1SccBase_JointTransformVector_m_Initialize(asn1SccBase_JointTransformVector_m* pVal);
flag asn1SccBase_JointTransformVector_m_IsConstraintValid(const asn1SccBase_JointTransformVector_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_Base_JointTransform_names;

#define asn1SccBase_NamedVector_Base_JointTransform_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_Base_JointTransform_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_Base_JointTransform_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_Base_JointTransform_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_Base_JointTransform_names_REQUIRED_BYTES_FOR_XER_ENCODING   84289

void asn1SccBase_NamedVector_Base_JointTransform_names_Initialize(asn1SccBase_NamedVector_Base_JointTransform_names* pVal);
flag asn1SccBase_NamedVector_Base_JointTransform_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointTransform_names 
#define ERR_asn1SccBase_NamedVector_Base_JointTransform_names		1076  /*(SIZE(1 .. numBase-NamedVector-Base-JointTransform-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_Base_JointTransform_names names;
    asn1SccBase_NamedVector_Base_JointTransform_elements elements;
} asn1SccBase_NamedVector_Base_JointTransform;

#define asn1SccBase_NamedVector_Base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       128452 
#define asn1SccBase_NamedVector_Base_JointTransform_REQUIRED_BITS_FOR_ENCODING        1027616
#define asn1SccBase_NamedVector_Base_JointTransform_REQUIRED_BYTES_FOR_ACN_ENCODING   128452 
#define asn1SccBase_NamedVector_Base_JointTransform_REQUIRED_BITS_FOR_ACN_ENCODING    1027616
#define asn1SccBase_NamedVector_Base_JointTransform_REQUIRED_BYTES_FOR_XER_ENCODING   314713

void asn1SccBase_NamedVector_Base_JointTransform_Initialize(asn1SccBase_NamedVector_Base_JointTransform* pVal);
flag asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_JointTransformVector_names;

#define asn1SccBase_JointTransformVector_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_JointTransformVector_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_JointTransformVector_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_JointTransformVector_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_JointTransformVector_names_REQUIRED_BYTES_FOR_XER_ENCODING   84267

void asn1SccBase_JointTransformVector_names_Initialize(asn1SccBase_JointTransformVector_names* pVal);
flag asn1SccBase_JointTransformVector_names_IsConstraintValid(const asn1SccBase_JointTransformVector_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointTransformVector_names 
#define ERR_asn1SccBase_JointTransformVector_names		1077  /*(SIZE(1 .. numBase-JointTransformVector-names))*/
#endif

typedef struct {
    asn1SccBase_JointTransformVector_names names;
    asn1SccBase_JointTransformVector_elements elements;
} asn1SccBase_JointTransformVector;

#define asn1SccBase_JointTransformVector_REQUIRED_BYTES_FOR_ENCODING       128452 
#define asn1SccBase_JointTransformVector_REQUIRED_BITS_FOR_ENCODING        1027616
#define asn1SccBase_JointTransformVector_REQUIRED_BYTES_FOR_ACN_ENCODING   128452 
#define asn1SccBase_JointTransformVector_REQUIRED_BITS_FOR_ACN_ENCODING    1027616
#define asn1SccBase_JointTransformVector_REQUIRED_BYTES_FOR_XER_ENCODING   314691

void asn1SccBase_JointTransformVector_Initialize(asn1SccBase_JointTransformVector* pVal);
flag asn1SccBase_JointTransformVector_IsConstraintValid(const asn1SccBase_JointTransformVector* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_samples_Wrenches_names;

#define asn1SccBase_samples_Wrenches_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_samples_Wrenches_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_samples_Wrenches_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_samples_Wrenches_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_samples_Wrenches_names_REQUIRED_BYTES_FOR_XER_ENCODING   84259

void asn1SccBase_samples_Wrenches_names_Initialize(asn1SccBase_samples_Wrenches_names* pVal);
flag asn1SccBase_samples_Wrenches_names_IsConstraintValid(const asn1SccBase_samples_Wrenches_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_Wrenches_names 
#define ERR_asn1SccBase_samples_Wrenches_names		1078  /*(SIZE(1 .. numBase-samples-Wrenches-names))*/
#endif

typedef struct {
    asn1SccBase_samples_Wrenches_names names;
    asn1SccBase_samples_Wrenches_elements elements;
    asn1SccBase_Time time;
} asn1SccBase_samples_Wrenches;

#define asn1SccBase_samples_Wrenches_REQUIRED_BYTES_FOR_ENCODING       55910 
#define asn1SccBase_samples_Wrenches_REQUIRED_BITS_FOR_ENCODING        447280
#define asn1SccBase_samples_Wrenches_REQUIRED_BYTES_FOR_ACN_ENCODING   55910 
#define asn1SccBase_samples_Wrenches_REQUIRED_BITS_FOR_ACN_ENCODING    447280
#define asn1SccBase_samples_Wrenches_REQUIRED_BYTES_FOR_XER_ENCODING   186545

void asn1SccBase_samples_Wrenches_Initialize(asn1SccBase_samples_Wrenches* pVal);
flag asn1SccBase_samples_Wrenches_IsConstraintValid(const asn1SccBase_samples_Wrenches* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_commands_Joints_names;

#define asn1SccBase_commands_Joints_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_commands_Joints_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_commands_Joints_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_commands_Joints_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_commands_Joints_names_REQUIRED_BYTES_FOR_XER_ENCODING   84257

void asn1SccBase_commands_Joints_names_Initialize(asn1SccBase_commands_Joints_names* pVal);
flag asn1SccBase_commands_Joints_names_IsConstraintValid(const asn1SccBase_commands_Joints_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_commands_Joints_names 
#define ERR_asn1SccBase_commands_Joints_names		1079  /*(SIZE(1 .. numBase-commands-Joints-names))*/
#endif

typedef struct {
    asn1SccBase_commands_Joints_names names;
    asn1SccBase_JointTrajectory elements;
    asn1SccBase_Time time;
} asn1SccBase_commands_Joints;

#define asn1SccBase_commands_Joints_REQUIRED_BYTES_FOR_ENCODING       53210 
#define asn1SccBase_commands_Joints_REQUIRED_BITS_FOR_ENCODING        425680
#define asn1SccBase_commands_Joints_REQUIRED_BYTES_FOR_ACN_ENCODING   53210 
#define asn1SccBase_commands_Joints_REQUIRED_BITS_FOR_ACN_ENCODING    425680
#define asn1SccBase_commands_Joints_REQUIRED_BYTES_FOR_XER_ENCODING   159943

void asn1SccBase_commands_Joints_Initialize(asn1SccBase_commands_Joints* pVal);
flag asn1SccBase_commands_Joints_IsConstraintValid(const asn1SccBase_commands_Joints* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_Base_JointTrajectory_names;

#define asn1SccBase_NamedVector_Base_JointTrajectory_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_Base_JointTrajectory_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_Base_JointTrajectory_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_Base_JointTrajectory_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_Base_JointTrajectory_names_REQUIRED_BYTES_FOR_XER_ENCODING   84291

void asn1SccBase_NamedVector_Base_JointTrajectory_names_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal);
flag asn1SccBase_NamedVector_Base_JointTrajectory_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointTrajectory_names 
#define ERR_asn1SccBase_NamedVector_Base_JointTrajectory_names		1080  /*(SIZE(1 .. numBase-NamedVector-Base-JointTrajectory-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_Base_JointTrajectory_names names;
    asn1SccBase_NamedVector_Base_JointTrajectory_elements elements;
} asn1SccBase_NamedVector_Base_JointTrajectory;

#define asn1SccBase_NamedVector_Base_JointTrajectory_REQUIRED_BYTES_FOR_ENCODING       2640402 
#define asn1SccBase_NamedVector_Base_JointTrajectory_REQUIRED_BITS_FOR_ENCODING        21123216
#define asn1SccBase_NamedVector_Base_JointTrajectory_REQUIRED_BYTES_FOR_ACN_ENCODING   2640402 
#define asn1SccBase_NamedVector_Base_JointTrajectory_REQUIRED_BITS_FOR_ACN_ENCODING    21123216
#define asn1SccBase_NamedVector_Base_JointTrajectory_REQUIRED_BYTES_FOR_XER_ENCODING   15213315

void asn1SccBase_NamedVector_Base_JointTrajectory_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory* pVal);
flag asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_Base_Wrench_names;

#define asn1SccBase_NamedVector_Base_Wrench_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_Base_Wrench_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_Base_Wrench_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_Base_Wrench_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_Base_Wrench_names_REQUIRED_BYTES_FOR_XER_ENCODING   84273

void asn1SccBase_NamedVector_Base_Wrench_names_Initialize(asn1SccBase_NamedVector_Base_Wrench_names* pVal);
flag asn1SccBase_NamedVector_Base_Wrench_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_Wrench_names 
#define ERR_asn1SccBase_NamedVector_Base_Wrench_names		1081  /*(SIZE(1 .. numBase-NamedVector-Base-Wrench-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_Base_Wrench_names names;
    asn1SccBase_NamedVector_Base_Wrench_elements elements;
} asn1SccBase_NamedVector_Base_Wrench;

#define asn1SccBase_NamedVector_Base_Wrench_REQUIRED_BYTES_FOR_ENCODING       55902 
#define asn1SccBase_NamedVector_Base_Wrench_REQUIRED_BITS_FOR_ENCODING        447216
#define asn1SccBase_NamedVector_Base_Wrench_REQUIRED_BYTES_FOR_ACN_ENCODING   55902 
#define asn1SccBase_NamedVector_Base_Wrench_REQUIRED_BITS_FOR_ACN_ENCODING    447216
#define asn1SccBase_NamedVector_Base_Wrench_REQUIRED_BYTES_FOR_XER_ENCODING   186497

void asn1SccBase_NamedVector_Base_Wrench_Initialize(asn1SccBase_NamedVector_Base_Wrench* pVal);
flag asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_Base_JointState_names;

#define asn1SccBase_NamedVector_Base_JointState_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_Base_JointState_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_Base_JointState_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_Base_JointState_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_Base_JointState_names_REQUIRED_BYTES_FOR_XER_ENCODING   84281

void asn1SccBase_NamedVector_Base_JointState_names_Initialize(asn1SccBase_NamedVector_Base_JointState_names* pVal);
flag asn1SccBase_NamedVector_Base_JointState_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointState_names 
#define ERR_asn1SccBase_NamedVector_Base_JointState_names		1082  /*(SIZE(1 .. numBase-NamedVector-Base-JointState-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_Base_JointState_names names;
    asn1SccBase_JointTrajectory elements;
} asn1SccBase_NamedVector_Base_JointState;

#define asn1SccBase_NamedVector_Base_JointState_REQUIRED_BYTES_FOR_ENCODING       53202 
#define asn1SccBase_NamedVector_Base_JointState_REQUIRED_BITS_FOR_ENCODING        425616
#define asn1SccBase_NamedVector_Base_JointState_REQUIRED_BYTES_FOR_ACN_ENCODING   53202 
#define asn1SccBase_NamedVector_Base_JointState_REQUIRED_BITS_FOR_ACN_ENCODING    425616
#define asn1SccBase_NamedVector_Base_JointState_REQUIRED_BYTES_FOR_XER_ENCODING   159905

void asn1SccBase_NamedVector_Base_JointState_Initialize(asn1SccBase_NamedVector_Base_JointState* pVal);
flag asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_NamedVector_Base_JointLimitRange_names;

#define asn1SccBase_NamedVector_Base_JointLimitRange_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_NamedVector_Base_JointLimitRange_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_NamedVector_Base_JointLimitRange_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_NamedVector_Base_JointLimitRange_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_NamedVector_Base_JointLimitRange_names_REQUIRED_BYTES_FOR_XER_ENCODING   84291

void asn1SccBase_NamedVector_Base_JointLimitRange_names_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal);
flag asn1SccBase_NamedVector_Base_JointLimitRange_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_NamedVector_Base_JointLimitRange_names 
#define ERR_asn1SccBase_NamedVector_Base_JointLimitRange_names		1083  /*(SIZE(1 .. numBase-NamedVector-Base-JointLimitRange-names))*/
#endif

typedef struct {
    asn1SccBase_NamedVector_Base_JointLimitRange_names names;
    asn1SccBase_NamedVector_Base_JointLimitRange_elements elements;
} asn1SccBase_NamedVector_Base_JointLimitRange;

#define asn1SccBase_NamedVector_Base_JointLimitRange_REQUIRED_BYTES_FOR_ENCODING       66202 
#define asn1SccBase_NamedVector_Base_JointLimitRange_REQUIRED_BITS_FOR_ENCODING        529616
#define asn1SccBase_NamedVector_Base_JointLimitRange_REQUIRED_BYTES_FOR_ACN_ENCODING   66202 
#define asn1SccBase_NamedVector_Base_JointLimitRange_REQUIRED_BITS_FOR_ACN_ENCODING    529616
#define asn1SccBase_NamedVector_Base_JointLimitRange_REQUIRED_BYTES_FOR_XER_ENCODING   234915

void asn1SccBase_NamedVector_Base_JointLimitRange_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange* pVal);
flag asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_JointsTrajectory_names;

#define asn1SccBase_JointsTrajectory_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_JointsTrajectory_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_JointsTrajectory_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_JointsTrajectory_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_JointsTrajectory_names_REQUIRED_BYTES_FOR_XER_ENCODING   84259

void asn1SccBase_JointsTrajectory_names_Initialize(asn1SccBase_JointsTrajectory_names* pVal);
flag asn1SccBase_JointsTrajectory_names_IsConstraintValid(const asn1SccBase_JointsTrajectory_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointsTrajectory_names 
#define ERR_asn1SccBase_JointsTrajectory_names		1084  /*(SIZE(1 .. numBase-JointsTrajectory-names))*/
#endif

typedef struct {
    asn1SccBase_JointsTrajectory_names names;
    asn1SccBase_JointsTrajectory_elements elements;
    asn1SccBase_JointsTrajectory_times_t times_t;
} asn1SccBase_JointsTrajectory;

#define asn1SccBase_JointsTrajectory_REQUIRED_BYTES_FOR_ENCODING       2642003 
#define asn1SccBase_JointsTrajectory_REQUIRED_BITS_FOR_ENCODING        21136024
#define asn1SccBase_JointsTrajectory_REQUIRED_BYTES_FOR_ACN_ENCODING   2642003 
#define asn1SccBase_JointsTrajectory_REQUIRED_BITS_FOR_ACN_ENCODING    21136024
#define asn1SccBase_JointsTrajectory_REQUIRED_BYTES_FOR_XER_ENCODING   15227702

void asn1SccBase_JointsTrajectory_Initialize(asn1SccBase_JointsTrajectory* pVal);
flag asn1SccBase_JointsTrajectory_IsConstraintValid(const asn1SccBase_JointsTrajectory* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_String arr[200];
} asn1SccBase_JointLimits_names;

#define asn1SccBase_JointLimits_names_REQUIRED_BYTES_FOR_ENCODING       40201 
#define asn1SccBase_JointLimits_names_REQUIRED_BITS_FOR_ENCODING        321608
#define asn1SccBase_JointLimits_names_REQUIRED_BYTES_FOR_ACN_ENCODING   40201 
#define asn1SccBase_JointLimits_names_REQUIRED_BITS_FOR_ACN_ENCODING    321608
#define asn1SccBase_JointLimits_names_REQUIRED_BYTES_FOR_XER_ENCODING   84249

void asn1SccBase_JointLimits_names_Initialize(asn1SccBase_JointLimits_names* pVal);
flag asn1SccBase_JointLimits_names_IsConstraintValid(const asn1SccBase_JointLimits_names* val, int* pErrCode);
#ifndef ERR_asn1SccBase_JointLimits_names 
#define ERR_asn1SccBase_JointLimits_names		1085  /*(SIZE(1 .. numBase-JointLimits-names))*/
#endif

typedef struct {
    asn1SccBase_JointLimits_names names;
    asn1SccBase_JointLimits_elements elements;
} asn1SccBase_JointLimits;

#define asn1SccBase_JointLimits_REQUIRED_BYTES_FOR_ENCODING       66202 
#define asn1SccBase_JointLimits_REQUIRED_BITS_FOR_ENCODING        529616
#define asn1SccBase_JointLimits_REQUIRED_BYTES_FOR_ACN_ENCODING   66202 
#define asn1SccBase_JointLimits_REQUIRED_BITS_FOR_ACN_ENCODING    529616
#define asn1SccBase_JointLimits_REQUIRED_BYTES_FOR_XER_ENCODING   234873

void asn1SccBase_JointLimits_Initialize(asn1SccBase_JointLimits* pVal);
flag asn1SccBase_JointLimits_IsConstraintValid(const asn1SccBase_JointLimits* val, int* pErrCode);


typedef asn1SccSint asn1SccT_Int32;

#define asn1SccT_Int32_REQUIRED_BYTES_FOR_ENCODING       4 
#define asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING        32
#define asn1SccT_Int32_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define asn1SccT_Int32_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define asn1SccT_Int32_REQUIRED_BYTES_FOR_XER_ENCODING   39

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal);
flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* val, int* pErrCode);
#ifndef ERR_asn1SccT_Int32 
#define ERR_asn1SccT_Int32		1086  /*(-2147483648 .. 2147483647)*/
#endif

typedef struct {
    asn1SccT_Int32 rows;
    asn1SccT_Int32 cols;
    asn1SccWrappers_MatrixXd_data data;
} asn1SccWrappers_MatrixXd;

#define asn1SccWrappers_MatrixXd_REQUIRED_BYTES_FOR_ENCODING       2609 
#define asn1SccWrappers_MatrixXd_REQUIRED_BITS_FOR_ENCODING        20872
#define asn1SccWrappers_MatrixXd_REQUIRED_BYTES_FOR_ACN_ENCODING   2609 
#define asn1SccWrappers_MatrixXd_REQUIRED_BITS_FOR_ACN_ENCODING    20872
#define asn1SccWrappers_MatrixXd_REQUIRED_BYTES_FOR_XER_ENCODING   14318

void asn1SccWrappers_MatrixXd_Initialize(asn1SccWrappers_MatrixXd* pVal);
flag asn1SccWrappers_MatrixXd_IsConstraintValid(const asn1SccWrappers_MatrixXd* val, int* pErrCode);


typedef struct {
    asn1SccT_Double geometric_resolution;
    asn1SccT_Int32 dimension;
    asn1SccT_Int32 curve_order;
    asn1SccWrappers_geometry_SplineType kind;
    asn1SccWrappers_geometry_Spline_knots knots;
    asn1SccWrappers_geometry_Spline_vertices vertices;
} asn1SccWrappers_geometry_Spline;

#define asn1SccWrappers_geometry_Spline_REQUIRED_BYTES_FOR_ENCODING       5224 
#define asn1SccWrappers_geometry_Spline_REQUIRED_BITS_FOR_ENCODING        41787
#define asn1SccWrappers_geometry_Spline_REQUIRED_BYTES_FOR_ACN_ENCODING   5224 
#define asn1SccWrappers_geometry_Spline_REQUIRED_BITS_FOR_ACN_ENCODING    41787
#define asn1SccWrappers_geometry_Spline_REQUIRED_BYTES_FOR_XER_ENCODING   28722

void asn1SccWrappers_geometry_Spline_Initialize(asn1SccWrappers_geometry_Spline* pVal);
flag asn1SccWrappers_geometry_Spline_IsConstraintValid(const asn1SccWrappers_geometry_Spline* val, int* pErrCode);


typedef struct {
    asn1SccT_Double speed;
    asn1SccWrappers_geometry_Spline spline;
} asn1SccBase_Trajectory;

#define asn1SccBase_Trajectory_REQUIRED_BYTES_FOR_ENCODING       5237 
#define asn1SccBase_Trajectory_REQUIRED_BITS_FOR_ENCODING        41891
#define asn1SccBase_Trajectory_REQUIRED_BYTES_FOR_ACN_ENCODING   5237 
#define asn1SccBase_Trajectory_REQUIRED_BITS_FOR_ACN_ENCODING    41891
#define asn1SccBase_Trajectory_REQUIRED_BYTES_FOR_XER_ENCODING   28786

void asn1SccBase_Trajectory_Initialize(asn1SccBase_Trajectory* pVal);
flag asn1SccBase_Trajectory_IsConstraintValid(const asn1SccBase_Trajectory* val, int* pErrCode);


typedef struct {
    asn1SccT_Double speed;
    asn1SccWrappers_geometry_Spline spline;
} asn1SccBase_Trajectory_m;

#define asn1SccBase_Trajectory_m_REQUIRED_BYTES_FOR_ENCODING       5237 
#define asn1SccBase_Trajectory_m_REQUIRED_BITS_FOR_ENCODING        41891
#define asn1SccBase_Trajectory_m_REQUIRED_BYTES_FOR_ACN_ENCODING   5237 
#define asn1SccBase_Trajectory_m_REQUIRED_BITS_FOR_ACN_ENCODING    41891
#define asn1SccBase_Trajectory_m_REQUIRED_BYTES_FOR_XER_ENCODING   28790

void asn1SccBase_Trajectory_m_Initialize(asn1SccBase_Trajectory_m* pVal);
flag asn1SccBase_Trajectory_m_IsConstraintValid(const asn1SccBase_Trajectory_m* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccBase_Trajectory_m arr[200];
} asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory;

#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BYTES_FOR_ENCODING       1047276 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BITS_FOR_ENCODING        8378208
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BYTES_FOR_ACN_ENCODING   1047276 
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BITS_FOR_ACN_ENCODING    8378208
#define asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BYTES_FOR_XER_ENCODING   5758109

void asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal);
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* val, int* pErrCode);
#ifndef ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory 
#define ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory		1087  /*(SIZE(1 .. numStd-orogen-typekits-mtype-std-vector-base-Trajectory))*/
#endif

typedef asn1SccUint asn1SccT_UInt32;

#define asn1SccT_UInt32_REQUIRED_BYTES_FOR_ENCODING       4 
#define asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING        32
#define asn1SccT_UInt32_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define asn1SccT_UInt32_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define asn1SccT_UInt32_REQUIRED_BYTES_FOR_XER_ENCODING   41

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal);
flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* val, int* pErrCode);
#ifndef ERR_asn1SccT_UInt32 
#define ERR_asn1SccT_UInt32		1088  /*(0 .. 4294967295)*/
#endif

typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_samples_DepthMap_timestamps timestamps;
    asn1SccBase_samples_DepthMap_PROJECTION_TYPE vertical_projection;
    asn1SccBase_samples_DepthMap_PROJECTION_TYPE horizontal_projection;
    asn1SccBase_samples_DepthMap_vertical_interval vertical_interval;
    asn1SccBase_samples_DepthMap_horizontal_interval horizontal_interval;
    asn1SccT_UInt32 vertical_size;
    asn1SccT_UInt32 horizontal_size;
    asn1SccBase_samples_DepthMap_distances distances;
    asn1SccBase_samples_DepthMap_remissions remissions;
} asn1SccBase_samples_DepthMap;

#define asn1SccBase_samples_DepthMap_REQUIRED_BYTES_FOR_ENCODING       12022 
#define asn1SccBase_samples_DepthMap_REQUIRED_BITS_FOR_ENCODING        96170
#define asn1SccBase_samples_DepthMap_REQUIRED_BYTES_FOR_ACN_ENCODING   12022 
#define asn1SccBase_samples_DepthMap_REQUIRED_BITS_FOR_ACN_ENCODING    96170
#define asn1SccBase_samples_DepthMap_REQUIRED_BYTES_FOR_XER_ENCODING   70886

void asn1SccBase_samples_DepthMap_Initialize(asn1SccBase_samples_DepthMap* pVal);
flag asn1SccBase_samples_DepthMap_IsConstraintValid(const asn1SccBase_samples_DepthMap* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_samples_Sonar_timestamps timestamps;
    asn1SccBase_Time bin_duration;
    asn1SccBase_Angle beam_width;
    asn1SccBase_Angle beam_height;
    asn1SccBase_samples_Sonar_bearings bearings;
    asn1SccT_Float speed_of_sound;
    asn1SccT_UInt32 bin_count;
    asn1SccT_UInt32 beam_count;
    asn1SccBase_samples_Sonar_bins bins;
} asn1SccBase_samples_Sonar;

#define asn1SccBase_samples_Sonar_REQUIRED_BYTES_FOR_ENCODING       6866 
#define asn1SccBase_samples_Sonar_REQUIRED_BITS_FOR_ENCODING        54928
#define asn1SccBase_samples_Sonar_REQUIRED_BYTES_FOR_ACN_ENCODING   6866 
#define asn1SccBase_samples_Sonar_REQUIRED_BITS_FOR_ACN_ENCODING    54928
#define asn1SccBase_samples_Sonar_REQUIRED_BYTES_FOR_XER_ENCODING   45985

void asn1SccBase_samples_Sonar_Initialize(asn1SccBase_samples_Sonar* pVal);
flag asn1SccBase_samples_Sonar_IsConstraintValid(const asn1SccBase_samples_Sonar* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_UInt32 arr[200];
} asn1SccBase_samples_LaserScan_ranges;

#define asn1SccBase_samples_LaserScan_ranges_REQUIRED_BYTES_FOR_ENCODING       801 
#define asn1SccBase_samples_LaserScan_ranges_REQUIRED_BITS_FOR_ENCODING        6408
#define asn1SccBase_samples_LaserScan_ranges_REQUIRED_BYTES_FOR_ACN_ENCODING   801 
#define asn1SccBase_samples_LaserScan_ranges_REQUIRED_BITS_FOR_ACN_ENCODING    6408
#define asn1SccBase_samples_LaserScan_ranges_REQUIRED_BYTES_FOR_XER_ENCODING   8263

void asn1SccBase_samples_LaserScan_ranges_Initialize(asn1SccBase_samples_LaserScan_ranges* pVal);
flag asn1SccBase_samples_LaserScan_ranges_IsConstraintValid(const asn1SccBase_samples_LaserScan_ranges* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_LaserScan_ranges 
#define ERR_asn1SccBase_samples_LaserScan_ranges		1089  /*(SIZE(1 .. numBase-samples-LaserScan-ranges))*/
#endif

typedef struct {
    asn1SccBase_Time time;
    asn1SccT_Double start_angle;
    asn1SccT_Double angular_resolution;
    asn1SccT_Double speed;
    asn1SccBase_samples_LaserScan_ranges ranges;
    asn1SccT_UInt32 minrange;
    asn1SccT_UInt32 maxrange;
    asn1SccBase_samples_LaserScan_remission remission;
} asn1SccBase_samples_LaserScan;

#define asn1SccBase_samples_LaserScan_REQUIRED_BYTES_FOR_ENCODING       3457 
#define asn1SccBase_samples_LaserScan_REQUIRED_BITS_FOR_ENCODING        27656
#define asn1SccBase_samples_LaserScan_REQUIRED_BYTES_FOR_ACN_ENCODING   3457 
#define asn1SccBase_samples_LaserScan_REQUIRED_BITS_FOR_ACN_ENCODING    27656
#define asn1SccBase_samples_LaserScan_REQUIRED_BYTES_FOR_XER_ENCODING   22466

void asn1SccBase_samples_LaserScan_Initialize(asn1SccBase_samples_LaserScan* pVal);
flag asn1SccBase_samples_LaserScan_IsConstraintValid(const asn1SccBase_samples_LaserScan* val, int* pErrCode);


typedef asn1SccT_UInt32 asn1SccDummy_T;

#define asn1SccDummy_T_REQUIRED_BYTES_FOR_ENCODING       4 
#define asn1SccDummy_T_REQUIRED_BITS_FOR_ENCODING        32
#define asn1SccDummy_T_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define asn1SccDummy_T_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define asn1SccDummy_T_REQUIRED_BYTES_FOR_XER_ENCODING   39

void asn1SccDummy_T_Initialize(asn1SccDummy_T* pVal);
flag asn1SccDummy_T_IsConstraintValid(const asn1SccDummy_T* val, int* pErrCode);


typedef asn1SccDummy_T asn1SccDummy2_T;

#define asn1SccDummy2_T_REQUIRED_BYTES_FOR_ENCODING       4 
#define asn1SccDummy2_T_REQUIRED_BITS_FOR_ENCODING        32
#define asn1SccDummy2_T_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define asn1SccDummy2_T_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define asn1SccDummy2_T_REQUIRED_BYTES_FOR_XER_ENCODING   41

void asn1SccDummy2_T_Initialize(asn1SccDummy2_T* pVal);
flag asn1SccDummy2_T_IsConstraintValid(const asn1SccDummy2_T* val, int* pErrCode);


typedef asn1SccDummy_T asn1SccDummy3T;

#define asn1SccDummy3T_REQUIRED_BYTES_FOR_ENCODING       4 
#define asn1SccDummy3T_REQUIRED_BITS_FOR_ENCODING        32
#define asn1SccDummy3T_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define asn1SccDummy3T_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define asn1SccDummy3T_REQUIRED_BYTES_FOR_XER_ENCODING   39

void asn1SccDummy3T_Initialize(asn1SccDummy3T* pVal);
flag asn1SccDummy3T_IsConstraintValid(const asn1SccDummy3T* val, int* pErrCode);


typedef asn1SccSint asn1SccT_Int8;

#define asn1SccT_Int8_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING        8
#define asn1SccT_Int8_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccT_Int8_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define asn1SccT_Int8_REQUIRED_BYTES_FOR_XER_ENCODING   37

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal);
flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* val, int* pErrCode);
#ifndef ERR_asn1SccT_Int8 
#define ERR_asn1SccT_Int8		1090  /*(-128 .. 127)*/
#endif

typedef asn1SccUint asn1SccT_UInt8;

#define asn1SccT_UInt8_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING        8
#define asn1SccT_UInt8_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccT_UInt8_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define asn1SccT_UInt8_REQUIRED_BYTES_FOR_XER_ENCODING   39

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal);
flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* val, int* pErrCode);
#ifndef ERR_asn1SccT_UInt8 
#define ERR_asn1SccT_UInt8		1091  /*(0 .. 255)*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_UInt8 arr[200];
} asn1SccBase_samples_frame_Frame_image;

#define asn1SccBase_samples_frame_Frame_image_REQUIRED_BYTES_FOR_ENCODING       201 
#define asn1SccBase_samples_frame_Frame_image_REQUIRED_BITS_FOR_ENCODING        1608
#define asn1SccBase_samples_frame_Frame_image_REQUIRED_BYTES_FOR_ACN_ENCODING   201 
#define asn1SccBase_samples_frame_Frame_image_REQUIRED_BITS_FOR_ACN_ENCODING    1608
#define asn1SccBase_samples_frame_Frame_image_REQUIRED_BYTES_FOR_XER_ENCODING   7865

void asn1SccBase_samples_frame_Frame_image_Initialize(asn1SccBase_samples_frame_Frame_image* pVal);
flag asn1SccBase_samples_frame_Frame_image_IsConstraintValid(const asn1SccBase_samples_frame_Frame_image* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_frame_Frame_image 
#define ERR_asn1SccBase_samples_frame_Frame_image		1092  /*(SIZE(1 .. numBase-samples-frame-Frame-image))*/
#endif

typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_Time received_time;
    asn1SccBase_samples_frame_Frame_image image;
    asn1SccBase_samples_frame_Frame_attributes attributes;
    asn1SccBase_samples_frame_frame_size_t size_t;
    asn1SccT_UInt32 data_depth;
    asn1SccT_UInt32 pixel_size;
    asn1SccT_UInt32 row_size;
    asn1SccBase_samples_frame_frame_mode_t frame_mode;
    asn1SccBase_samples_frame_frame_status_t frame_status;
} asn1SccBase_samples_frame_Frame;

#define asn1SccBase_samples_frame_Frame_REQUIRED_BYTES_FOR_ENCODING       80635 
#define asn1SccBase_samples_frame_Frame_REQUIRED_BITS_FOR_ENCODING        645078
#define asn1SccBase_samples_frame_Frame_REQUIRED_BYTES_FOR_ACN_ENCODING   80635 
#define asn1SccBase_samples_frame_Frame_REQUIRED_BITS_FOR_ACN_ENCODING    645078
#define asn1SccBase_samples_frame_Frame_REQUIRED_BYTES_FOR_XER_ENCODING   188557

void asn1SccBase_samples_frame_Frame_Initialize(asn1SccBase_samples_frame_Frame* pVal);
flag asn1SccBase_samples_frame_Frame_IsConstraintValid(const asn1SccBase_samples_frame_Frame* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_samples_frame_Frame first;
    asn1SccBase_samples_frame_Frame second;
    asn1SccT_UInt32 id;
} asn1SccBase_samples_frame_FramePair;

#define asn1SccBase_samples_frame_FramePair_REQUIRED_BYTES_FOR_ENCODING       161282 
#define asn1SccBase_samples_frame_FramePair_REQUIRED_BITS_FOR_ENCODING        1290252
#define asn1SccBase_samples_frame_FramePair_REQUIRED_BYTES_FOR_ACN_ENCODING   161282 
#define asn1SccBase_samples_frame_FramePair_REQUIRED_BITS_FOR_ACN_ENCODING    1290252
#define asn1SccBase_samples_frame_FramePair_REQUIRED_BYTES_FOR_XER_ENCODING   377192

void asn1SccBase_samples_frame_FramePair_Initialize(asn1SccBase_samples_frame_FramePair* pVal);
flag asn1SccBase_samples_frame_FramePair_IsConstraintValid(const asn1SccBase_samples_frame_FramePair* val, int* pErrCode);


typedef struct {    int nCount; 
    
    asn1SccT_UInt8 arr[200];
} asn1SccBase_samples_SonarScan_data;

#define asn1SccBase_samples_SonarScan_data_REQUIRED_BYTES_FOR_ENCODING       201 
#define asn1SccBase_samples_SonarScan_data_REQUIRED_BITS_FOR_ENCODING        1608
#define asn1SccBase_samples_SonarScan_data_REQUIRED_BYTES_FOR_ACN_ENCODING   201 
#define asn1SccBase_samples_SonarScan_data_REQUIRED_BITS_FOR_ACN_ENCODING    1608
#define asn1SccBase_samples_SonarScan_data_REQUIRED_BYTES_FOR_XER_ENCODING   7859

void asn1SccBase_samples_SonarScan_data_Initialize(asn1SccBase_samples_SonarScan_data* pVal);
flag asn1SccBase_samples_SonarScan_data_IsConstraintValid(const asn1SccBase_samples_SonarScan_data* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_SonarScan_data 
#define ERR_asn1SccBase_samples_SonarScan_data		1093  /*(SIZE(1 .. numBase-samples-SonarScan-data))*/
#endif

typedef struct {    int nCount; 
    
    asn1SccT_UInt8 arr[200];
} asn1SccBase_samples_SonarBeam_beam;

#define asn1SccBase_samples_SonarBeam_beam_REQUIRED_BYTES_FOR_ENCODING       201 
#define asn1SccBase_samples_SonarBeam_beam_REQUIRED_BITS_FOR_ENCODING        1608
#define asn1SccBase_samples_SonarBeam_beam_REQUIRED_BYTES_FOR_ACN_ENCODING   201 
#define asn1SccBase_samples_SonarBeam_beam_REQUIRED_BITS_FOR_ACN_ENCODING    1608
#define asn1SccBase_samples_SonarBeam_beam_REQUIRED_BYTES_FOR_XER_ENCODING   7859

void asn1SccBase_samples_SonarBeam_beam_Initialize(asn1SccBase_samples_SonarBeam_beam* pVal);
flag asn1SccBase_samples_SonarBeam_beam_IsConstraintValid(const asn1SccBase_samples_SonarBeam_beam* val, int* pErrCode);
#ifndef ERR_asn1SccBase_samples_SonarBeam_beam 
#define ERR_asn1SccBase_samples_SonarBeam_beam		1094  /*(SIZE(1 .. numBase-samples-SonarBeam-beam))*/
#endif

typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_Angle bearing;
    asn1SccT_Double sampling_interval;
    asn1SccT_Float speed_of_sound;
    asn1SccT_Float beamwidth_horizontal;
    asn1SccT_Float beamwidth_vertical;
    asn1SccBase_samples_SonarBeam_beam beam;
} asn1SccBase_samples_SonarBeam;

#define asn1SccBase_samples_SonarBeam_REQUIRED_BYTES_FOR_ENCODING       274 
#define asn1SccBase_samples_SonarBeam_REQUIRED_BITS_FOR_ENCODING        2192
#define asn1SccBase_samples_SonarBeam_REQUIRED_BYTES_FOR_ACN_ENCODING   274 
#define asn1SccBase_samples_SonarBeam_REQUIRED_BITS_FOR_ACN_ENCODING    2192
#define asn1SccBase_samples_SonarBeam_REQUIRED_BYTES_FOR_XER_ENCODING   8362

void asn1SccBase_samples_SonarBeam_Initialize(asn1SccBase_samples_SonarBeam* pVal);
flag asn1SccBase_samples_SonarBeam_IsConstraintValid(const asn1SccBase_samples_SonarBeam* val, int* pErrCode);


typedef flag asn1SccT_Boolean;

#define asn1SccT_Boolean_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING        1
#define asn1SccT_Boolean_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccT_Boolean_REQUIRED_BITS_FOR_ACN_ENCODING    1
#define asn1SccT_Boolean_REQUIRED_BYTES_FOR_XER_ENCODING   36

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal);
flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* val, int* pErrCode);


typedef struct {
    asn1SccBase_Time time;
    asn1SccBase_samples_SonarScan_data data;
    asn1SccBase_samples_SonarScan_time_beams time_beams;
    asn1SccT_UInt16 number_of_beams;
    asn1SccT_UInt16 number_of_bins;
    asn1SccBase_Angle start_bearing;
    asn1SccBase_Angle angular_resolution;
    asn1SccT_Double sampling_interval;
    asn1SccT_Float speed_of_sound;
    asn1SccBase_Angle beamwidth_horizontal;
    asn1SccBase_Angle beamwidth_vertical;
    asn1SccT_Boolean memory_layout_column;
    asn1SccT_Boolean polar_coordinates;
} asn1SccBase_samples_SonarScan;

#define asn1SccBase_samples_SonarScan_REQUIRED_BYTES_FOR_ENCODING       1893 
#define asn1SccBase_samples_SonarScan_REQUIRED_BITS_FOR_ENCODING        15138
#define asn1SccBase_samples_SonarScan_REQUIRED_BYTES_FOR_ACN_ENCODING   1893 
#define asn1SccBase_samples_SonarScan_REQUIRED_BITS_FOR_ACN_ENCODING    15138
#define asn1SccBase_samples_SonarScan_REQUIRED_BYTES_FOR_XER_ENCODING   23141

void asn1SccBase_samples_SonarScan_Initialize(asn1SccBase_samples_SonarScan* pVal);
flag asn1SccBase_samples_SonarScan_IsConstraintValid(const asn1SccBase_samples_SonarScan* val, int* pErrCode);


typedef char asn1SccVizkit3D_FilePath[256];

#define asn1SccVizkit3D_FilePath_REQUIRED_BYTES_FOR_ENCODING       225 
#define asn1SccVizkit3D_FilePath_REQUIRED_BITS_FOR_ENCODING        1793
#define asn1SccVizkit3D_FilePath_REQUIRED_BYTES_FOR_ACN_ENCODING   225 
#define asn1SccVizkit3D_FilePath_REQUIRED_BITS_FOR_ACN_ENCODING    1793
#define asn1SccVizkit3D_FilePath_REQUIRED_BYTES_FOR_XER_ENCODING   294

void asn1SccVizkit3D_FilePath_Initialize(asn1SccVizkit3D_FilePath pVal);
flag asn1SccVizkit3D_FilePath_IsConstraintValid(const asn1SccVizkit3D_FilePath val, int* pErrCode);
#ifndef ERR_asn1SccVizkit3D_FilePath 
#define ERR_asn1SccVizkit3D_FilePath		1095  /*(SIZE(0 .. vizkit3d-PathMaxSize))*/
#endif

typedef char asn1SccVizkit3D_PluginLabel[32];

#define asn1SccVizkit3D_PluginLabel_REQUIRED_BYTES_FOR_ENCODING       28 
#define asn1SccVizkit3D_PluginLabel_REQUIRED_BITS_FOR_ENCODING        222
#define asn1SccVizkit3D_PluginLabel_REQUIRED_BYTES_FOR_ACN_ENCODING   28 
#define asn1SccVizkit3D_PluginLabel_REQUIRED_BITS_FOR_ACN_ENCODING    222
#define asn1SccVizkit3D_PluginLabel_REQUIRED_BYTES_FOR_XER_ENCODING   76

void asn1SccVizkit3D_PluginLabel_Initialize(asn1SccVizkit3D_PluginLabel pVal);
flag asn1SccVizkit3D_PluginLabel_IsConstraintValid(const asn1SccVizkit3D_PluginLabel val, int* pErrCode);
#ifndef ERR_asn1SccVizkit3D_PluginLabel 
#define ERR_asn1SccVizkit3D_PluginLabel		1096  /*(SIZE(1 .. vizkit3d-LabelMaxSize))*/
#endif

extern const asn1SccT_UInt32 vizkit3d_PathMaxSize;
extern const asn1SccT_UInt32 vizkit3d_LabelMaxSize;
extern const asn1SccT_UInt32 numT_String;
extern const asn1SccT_UInt32 numBase_JointTrajectory;
extern const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform;
extern const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint;
extern const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench;
extern const asn1SccT_UInt32 numStd_vector_Wrappers_Vector4d;
extern const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory;
extern const asn1SccT_UInt32 numBase_JointLimits_names;
extern const asn1SccT_UInt32 numBase_JointLimits_elements;
extern const asn1SccT_UInt32 numBase_JointsTrajectory_names;
extern const asn1SccT_UInt32 numBase_JointsTrajectory_elements;
extern const asn1SccT_UInt32 numBase_JointsTrajectory_times_t;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointLimitRange_names;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointLimitRange_elements;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointState_names;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_Wrench_names;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_Wrench_elements;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointTrajectory_names;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointTrajectory_elements;
extern const asn1SccT_UInt32 numBase_samples_DepthMap_timestamps;
extern const asn1SccT_UInt32 numBase_samples_DepthMap_vertical_interval;
extern const asn1SccT_UInt32 numBase_samples_DepthMap_horizontal_interval;
extern const asn1SccT_UInt32 numBase_samples_DepthMap_distances;
extern const asn1SccT_UInt32 numBase_samples_DepthMap_remissions;
extern const asn1SccT_UInt32 numBase_samples_DistanceImage_data;
extern const asn1SccT_UInt32 numBase_commands_Joints_names;
extern const asn1SccT_UInt32 numBase_samples_LaserScan_ranges;
extern const asn1SccT_UInt32 numBase_samples_LaserScan_remission;
extern const asn1SccT_UInt32 numBase_samples_Pointcloud_points;
extern const asn1SccT_UInt32 numBase_samples_Pointcloud_colors;
extern const asn1SccT_UInt32 numBase_samples_Sonar_timestamps;
extern const asn1SccT_UInt32 numBase_samples_Sonar_bearings;
extern const asn1SccT_UInt32 numBase_samples_Sonar_bins;
extern const asn1SccT_UInt32 numBase_samples_SonarBeam_beam;
extern const asn1SccT_UInt32 numBase_samples_SonarScan_data;
extern const asn1SccT_UInt32 numBase_samples_SonarScan_time_beams;
extern const asn1SccT_UInt32 numBase_samples_Wrenches_names;
extern const asn1SccT_UInt32 numBase_samples_Wrenches_elements;
extern const asn1SccT_UInt32 numBase_JointTransformVector_names;
extern const asn1SccT_UInt32 numBase_JointTransformVector_elements;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointTransform_names;
extern const asn1SccT_UInt32 numBase_NamedVector_Base_JointTransform_elements;
extern const asn1SccT_UInt32 numBase_samples_frame_Frame_image;
extern const asn1SccT_UInt32 numBase_samples_frame_Frame_attributes;
extern const asn1SccT_UInt32 numWrappers_MatrixXd_data;
extern const asn1SccT_UInt32 numWrappers_VectorXd_data;
extern const asn1SccT_UInt32 numBase_JointTransformVector_m_names;
extern const asn1SccT_UInt32 numBase_NamedVector_base_JointTransform_m_names;
extern const asn1SccT_UInt32 numBase_NamedVector_base_Wrench_m_names;
extern const asn1SccT_UInt32 numBase_samples_Pointcloud_m_points;
extern const asn1SccT_UInt32 numBase_samples_Pointcloud_m_colors;
extern const asn1SccT_UInt32 numBase_samples_Wrenches_m_names;
extern const asn1SccT_UInt32 numWrappers_geometry_Spline_knots;
extern const asn1SccT_UInt32 numWrappers_geometry_Spline_vertices; 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */









































































































































































 


#ifdef  __cplusplus
}
#define ENUM_asn1Sccacceleration	asn1Sccacceleration
#define ENUM_asn1Scceffort	asn1Scceffort
#define ENUM_asn1Sccposition	asn1Sccposition
#define ENUM_asn1Sccraw	asn1Sccraw
#define ENUM_asn1Sccspeed	asn1Sccspeed
#define ENUM_asn1Sccunset	asn1Sccunset
#define ENUM_asn1Sccmicroseconds	asn1Sccmicroseconds
#define ENUM_asn1Sccmilliseconds	asn1Sccmilliseconds
#define ENUM_asn1Sccseconds	asn1Sccseconds
#define ENUM_asn1Sccderivative_to_next	asn1Sccderivative_to_next
#define ENUM_asn1Sccderivative_to_prior	asn1Sccderivative_to_prior
#define ENUM_asn1Sccknuckle_point	asn1Sccknuckle_point
#define ENUM_asn1Sccordinary_point	asn1Sccordinary_point
#define ENUM_asn1Sccsecond_derivative_to_next	asn1Sccsecond_derivative_to_next
#define ENUM_asn1Sccsecond_derivative_to_prior	asn1Sccsecond_derivative_to_prior
#define ENUM_asn1Scctangent_point_for_next	asn1Scctangent_point_for_next
#define ENUM_asn1Scctangent_point_for_prior	asn1Scctangent_point_for_prior
#define ENUM_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_measurement_error	asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_measurement_error
#define ENUM_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_far	asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_far
#define ENUM_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_near	asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_near
#define ENUM_asn1Sccvalid_measurement	asn1Sccvalid_measurement
#define ENUM_asn1Sccplanar	asn1Sccplanar
#define ENUM_asn1Sccpolar	asn1Sccpolar
#define ENUM_asn1Sccunit_x	asn1Sccunit_x
#define ENUM_asn1Sccunit_y	asn1Sccunit_y
#define ENUM_asn1Sccunit_z	asn1Sccunit_z
#define ENUM_asn1Sccend_laser_range_errors	asn1Sccend_laser_range_errors
#define ENUM_asn1Sccmax_range_error	asn1Sccmax_range_error
#define ENUM_asn1SccBase_samples_LASER_RANGE_ERRORS_measurement_error	asn1SccBase_samples_LASER_RANGE_ERRORS_measurement_error
#define ENUM_asn1Sccother_range_errors	asn1Sccother_range_errors
#define ENUM_asn1SccBase_samples_LASER_RANGE_ERRORS_too_far	asn1SccBase_samples_LASER_RANGE_ERRORS_too_far
#define ENUM_asn1SccBase_samples_LASER_RANGE_ERRORS_too_near	asn1SccBase_samples_LASER_RANGE_ERRORS_too_near
#define ENUM_asn1Scccompressed_modes	asn1Scccompressed_modes
#define ENUM_asn1Sccmode_bayer	asn1Sccmode_bayer
#define ENUM_asn1Sccmode_bayer_bggr	asn1Sccmode_bayer_bggr
#define ENUM_asn1Sccmode_bayer_gbrg	asn1Sccmode_bayer_gbrg
#define ENUM_asn1Sccmode_bayer_grbg	asn1Sccmode_bayer_grbg
#define ENUM_asn1Sccmode_bayer_rggb	asn1Sccmode_bayer_rggb
#define ENUM_asn1Sccmode_bgr	asn1Sccmode_bgr
#define ENUM_asn1Sccmode_grayscale	asn1Sccmode_grayscale
#define ENUM_asn1Sccmode_jpeg	asn1Sccmode_jpeg
#define ENUM_asn1Sccmode_pjpg	asn1Sccmode_pjpg
#define ENUM_asn1Sccmode_png	asn1Sccmode_png
#define ENUM_asn1Sccmode_rgb	asn1Sccmode_rgb
#define ENUM_asn1Sccmode_rgb32	asn1Sccmode_rgb32
#define ENUM_asn1Sccmode_undefined	asn1Sccmode_undefined
#define ENUM_asn1Sccmode_uyvy	asn1Sccmode_uyvy
#define ENUM_asn1Sccraw_modes	asn1Sccraw_modes
#define ENUM_asn1Sccstatus_empty	asn1Sccstatus_empty
#define ENUM_asn1Sccstatus_invalid	asn1Sccstatus_invalid
#define ENUM_asn1Sccstatus_valid	asn1Sccstatus_valid
#define ENUM_asn1Sccdegenerate	asn1Sccdegenerate
#define ENUM_asn1Sccpolynomial_bezier	asn1Sccpolynomial_bezier
#define ENUM_asn1Sccpolynomial_bspline	asn1Sccpolynomial_bspline
#define ENUM_asn1Sccrational_bezier	asn1Sccrational_bezier
#define ENUM_asn1Sccrational_bspline	asn1Sccrational_bspline

#endif

#endif
