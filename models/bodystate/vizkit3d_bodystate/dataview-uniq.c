/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointState_MODE_Initialize(asn1SccBase_JointState_MODE* pVal)
{
    *pVal = (asn1SccBase_JointState_MODE) asn1Sccacceleration;
}
#endif

 
flag asn1SccBase_JointState_MODE_IsConstraintValid(const asn1SccBase_JointState_MODE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((*pVal == asn1Sccacceleration) || (*pVal == asn1Scceffort)) || (*pVal == asn1Sccposition)) || (*pVal == asn1Sccraw)) || (*pVal == asn1Sccspeed)) || (*pVal == asn1Sccunset));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointState_MODE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Time_Resolution_Initialize(asn1SccBase_Time_Resolution* pVal)
{
    *pVal = (asn1SccBase_Time_Resolution) asn1Sccmicroseconds;
}
#endif

 
flag asn1SccBase_Time_Resolution_IsConstraintValid(const asn1SccBase_Time_Resolution* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccmicroseconds) || (*pVal == asn1Sccmilliseconds)) || (*pVal == asn1Sccseconds));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_Time_Resolution;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_geometry_SplineBase_CoordinateType_Initialize(asn1SccBase_geometry_SplineBase_CoordinateType* pVal)
{
    *pVal = (asn1SccBase_geometry_SplineBase_CoordinateType) asn1Sccderivative_to_next;
}
#endif

 
flag asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(const asn1SccBase_geometry_SplineBase_CoordinateType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((*pVal == asn1Sccderivative_to_next) || (*pVal == asn1Sccderivative_to_prior)) || (*pVal == asn1Sccknuckle_point)) || (*pVal == asn1Sccordinary_point)) || (*pVal == asn1Sccsecond_derivative_to_next)) || (*pVal == asn1Sccsecond_derivative_to_prior)) || (*pVal == asn1Scctangent_point_for_next)) || (*pVal == asn1Scctangent_point_for_prior));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_geometry_SplineBase_CoordinateType;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE) asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_measurement_error;
}
#endif

 
flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_measurement_error) || (*pVal == asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_far)) || (*pVal == asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_too_near)) || (*pVal == asn1Sccvalid_measurement));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Initialize(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_PROJECTION_TYPE) asn1Sccplanar;
}
#endif

 
flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccplanar) || (*pVal == asn1Sccpolar));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_PROJECTION_TYPE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_UNIT_AXIS_Initialize(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_UNIT_AXIS) asn1Sccunit_x;
}
#endif

 
flag asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccunit_x) || (*pVal == asn1Sccunit_y)) || (*pVal == asn1Sccunit_z));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_UNIT_AXIS;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LASER_RANGE_ERRORS_Initialize(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal)
{
    *pVal = (asn1SccBase_samples_LASER_RANGE_ERRORS) asn1Sccend_laser_range_errors;
}
#endif

 
flag asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(const asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((*pVal == asn1Sccend_laser_range_errors) || (*pVal == asn1Sccmax_range_error)) || (*pVal == asn1SccBase_samples_LASER_RANGE_ERRORS_measurement_error)) || (*pVal == asn1Sccother_range_errors)) || (*pVal == asn1SccBase_samples_LASER_RANGE_ERRORS_too_far)) || (*pVal == asn1SccBase_samples_LASER_RANGE_ERRORS_too_near));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_LASER_RANGE_ERRORS;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_mode_t_Initialize(asn1SccBase_samples_frame_frame_mode_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_mode_t) asn1Scccompressed_modes;
}
#endif

 
flag asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_mode_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((((((((((*pVal == asn1Scccompressed_modes) || (*pVal == asn1Sccmode_bayer)) || (*pVal == asn1Sccmode_bayer_bggr)) || (*pVal == asn1Sccmode_bayer_gbrg)) || (*pVal == asn1Sccmode_bayer_grbg)) || (*pVal == asn1Sccmode_bayer_rggb)) || (*pVal == asn1Sccmode_bgr)) || (*pVal == asn1Sccmode_grayscale)) || (*pVal == asn1Sccmode_jpeg)) || (*pVal == asn1Sccmode_pjpg)) || (*pVal == asn1Sccmode_png)) || (*pVal == asn1Sccmode_rgb)) || (*pVal == asn1Sccmode_rgb32)) || (*pVal == asn1Sccmode_undefined)) || (*pVal == asn1Sccmode_uyvy)) || (*pVal == asn1Sccraw_modes));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_frame_mode_t;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_status_t_Initialize(asn1SccBase_samples_frame_frame_status_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_status_t) asn1Sccstatus_empty;
}
#endif

 
flag asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_status_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccstatus_empty) || (*pVal == asn1Sccstatus_invalid)) || (*pVal == asn1Sccstatus_valid));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_frame_status_t;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_SplineType_Initialize(asn1SccWrappers_geometry_SplineType* pVal)
{
    *pVal = (asn1SccWrappers_geometry_SplineType) asn1Sccdegenerate;
}
#endif

 
flag asn1SccWrappers_geometry_SplineType_IsConstraintValid(const asn1SccWrappers_geometry_SplineType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((((*pVal == asn1Sccdegenerate) || (*pVal == asn1Sccpolynomial_bezier)) || (*pVal == asn1Sccpolynomial_bspline)) || (*pVal == asn1Sccrational_bezier)) || (*pVal == asn1Sccrational_bspline));
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_geometry_SplineType;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Double_Initialize(asn1SccT_Double* pVal)
{
    *pVal = (asn1SccT_Double) 0.00000000000000000000E+000;
}
#endif

 
flag asn1SccT_Double_IsConstraintValid(const asn1SccT_Double* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-1.79769313486231570000E+308 <= *pVal && *pVal <= 1.79769313486231570000E+308);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Double;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Angle_Initialize(asn1SccBase_Angle* pVal)
{
    *pVal = (asn1SccBase_Angle) {
    .rad = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Angle_IsConstraintValid(const asn1SccBase_Angle* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->rad, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Motion2D_Initialize(asn1SccBase_commands_Motion2D* pVal)
{
    *pVal = (asn1SccBase_commands_Motion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000,
    .heading = {
        .rad = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_commands_Motion2D_IsConstraintValid(const asn1SccBase_commands_Motion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->heading, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_bearings_Initialize(asn1SccBase_samples_Sonar_bearings* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar_bearings) {    .nCount = 1,    .arr = 
    {
        {
            .rad = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_bearings_IsConstraintValid(const asn1SccBase_samples_Sonar_bearings* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Sonar_bearings);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Sonar_bearings;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_PoseUpdateThreshold_Initialize(asn1SccBase_PoseUpdateThreshold* pVal)
{
    *pVal = (asn1SccBase_PoseUpdateThreshold) {
    .distance = 0.00000000000000000000E+000,
    .angle = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_PoseUpdateThreshold_IsConstraintValid(const asn1SccBase_PoseUpdateThreshold* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->distance, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->angle, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Temperature_Initialize(asn1SccBase_Temperature* pVal)
{
    *pVal = (asn1SccBase_Temperature) {
    .kelvin = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Temperature_IsConstraintValid(const asn1SccBase_Temperature* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->kelvin, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Speed6D_Initialize(asn1SccBase_commands_Speed6D* pVal)
{
    *pVal = (asn1SccBase_commands_Speed6D) {
    .surge = 0.00000000000000000000E+000,
    .sway = 0.00000000000000000000E+000,
    .heave = 0.00000000000000000000E+000,
    .roll = 0.00000000000000000000E+000,
    .pitch = 0.00000000000000000000E+000,
    .yaw = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_commands_Speed6D_IsConstraintValid(const asn1SccBase_commands_Speed6D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->surge, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->sway, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->heave, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->roll, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Double_IsConstraintValid(&pVal->pitch, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Double_IsConstraintValid(&pVal->yaw, pErrCode);
	                
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_Spline_vertices_Initialize(asn1SccWrappers_geometry_Spline_vertices* pVal)
{
    *pVal = (asn1SccWrappers_geometry_Spline_vertices) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_geometry_Spline_vertices_IsConstraintValid(const asn1SccWrappers_geometry_Spline_vertices* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_geometry_Spline_vertices);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_geometry_Spline_vertices;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_Spline_knots_Initialize(asn1SccWrappers_geometry_Spline_knots* pVal)
{
    *pVal = (asn1SccWrappers_geometry_Spline_knots) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_geometry_Spline_knots_IsConstraintValid(const asn1SccWrappers_geometry_Spline_knots* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_geometry_Spline_knots);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_geometry_Spline_knots;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_VectorXd_data_Initialize(asn1SccWrappers_VectorXd_data* pVal)
{
    *pVal = (asn1SccWrappers_VectorXd_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_VectorXd_data_IsConstraintValid(const asn1SccWrappers_VectorXd_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_VectorXd_data);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_VectorXd_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_VectorXd_Initialize(asn1SccWrappers_VectorXd* pVal)
{
    *pVal = (asn1SccWrappers_VectorXd) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_VectorXd_IsConstraintValid(const asn1SccWrappers_VectorXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_VectorXd_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Quaterniond_im_Initialize(asn1SccWrappers_Quaterniond_im* pVal)
{
    *pVal = (asn1SccWrappers_Quaterniond_im) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Quaterniond_im_IsConstraintValid(const asn1SccWrappers_Quaterniond_im* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Quaterniond_im;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Quaterniond_Initialize(asn1SccWrappers_Quaterniond* pVal)
{
    *pVal = (asn1SccWrappers_Quaterniond) {
    .im = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .re = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccWrappers_Quaterniond_IsConstraintValid(const asn1SccWrappers_Quaterniond* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Quaterniond_im_IsConstraintValid(&pVal->im, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->re, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_MatrixXd_data_Initialize(asn1SccWrappers_MatrixXd_data* pVal)
{
    *pVal = (asn1SccWrappers_MatrixXd_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_MatrixXd_data_IsConstraintValid(const asn1SccWrappers_MatrixXd_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_MatrixXd_data);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_MatrixXd_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix6d_data_Initialize(asn1SccWrappers_Matrix6d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix6d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix6d_data_IsConstraintValid(const asn1SccWrappers_Matrix6d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 36);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix6d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix6d_Initialize(asn1SccWrappers_Matrix6d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix6d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix6d_IsConstraintValid(const asn1SccWrappers_Matrix6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix6d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector6d_data_Initialize(asn1SccWrappers_Vector6d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector6d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector6d_data_IsConstraintValid(const asn1SccWrappers_Vector6d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector6d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector6d_Initialize(asn1SccWrappers_Vector6d* pVal)
{
    *pVal = (asn1SccWrappers_Vector6d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector6d_IsConstraintValid(const asn1SccWrappers_Vector6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector6d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix4d_data_Initialize(asn1SccWrappers_Matrix4d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix4d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix4d_data_IsConstraintValid(const asn1SccWrappers_Matrix4d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 16);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix4d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix4d_Initialize(asn1SccWrappers_Matrix4d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix4d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix4d_IsConstraintValid(const asn1SccWrappers_Matrix4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix4d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector4d_data_Initialize(asn1SccWrappers_Vector4d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector4d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector4d_data_IsConstraintValid(const asn1SccWrappers_Vector4d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector4d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector4d_Initialize(asn1SccWrappers_Vector4d* pVal)
{
    *pVal = (asn1SccWrappers_Vector4d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector4d_IsConstraintValid(const asn1SccWrappers_Vector4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector4d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_vector_Wrappers_Vector4d_Initialize(asn1SccStd_vector_Wrappers_Vector4d* pVal)
{
    *pVal = (asn1SccStd_vector_Wrappers_Vector4d) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(const asn1SccStd_vector_Wrappers_Vector4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_vector_Wrappers_Vector4d);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_vector_Wrappers_Vector4d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_m_colors_Initialize(asn1SccBase_samples_Pointcloud_m_colors* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_m_colors) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_m_colors_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m_colors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_m_colors);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_m_colors;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_colors_Initialize(asn1SccBase_samples_Pointcloud_colors* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_colors) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_colors_IsConstraintValid(const asn1SccBase_samples_Pointcloud_colors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_colors);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_colors;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix3d_data_Initialize(asn1SccWrappers_Matrix3d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix3d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix3d_data_IsConstraintValid(const asn1SccWrappers_Matrix3d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 9);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix3d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix3d_Initialize(asn1SccWrappers_Matrix3d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix3d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix3d_IsConstraintValid(const asn1SccWrappers_Matrix3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix3d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector3d_data_Initialize(asn1SccWrappers_Vector3d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector3d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector3d_data_IsConstraintValid(const asn1SccWrappers_Vector3d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector3d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector3d_Initialize(asn1SccWrappers_Vector3d* pVal)
{
    *pVal = (asn1SccWrappers_Vector3d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector3d_IsConstraintValid(const asn1SccWrappers_Vector3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose_Initialize(asn1SccBase_Pose* pVal)
{
    *pVal = (asn1SccBase_Pose) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_Pose_IsConstraintValid(const asn1SccBase_Pose* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TransformWithCovariance_Initialize(asn1SccBase_TransformWithCovariance* pVal)
{
    *pVal = (asn1SccBase_TransformWithCovariance) {
    .translation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TransformWithCovariance_IsConstraintValid(const asn1SccBase_TransformWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TwistWithCovariance_Initialize(asn1SccBase_TwistWithCovariance* pVal)
{
    *pVal = (asn1SccBase_TwistWithCovariance) {
    .vel = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .rot = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TwistWithCovariance_IsConstraintValid(const asn1SccBase_TwistWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->vel, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rot, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Wrench_Initialize(asn1SccBase_Wrench* pVal)
{
    *pVal = (asn1SccBase_Wrench) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Wrench_IsConstraintValid(const asn1SccBase_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_elements_Initialize(asn1SccBase_samples_Wrenches_elements* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_elements) {    .nCount = 1,    .arr = 
    {
        {
            .force = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .torque = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_elements_IsConstraintValid(const asn1SccBase_samples_Wrenches_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Wrenches_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Wrenches_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Wrench_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_Wrench_elements_Initialize(asn1SccBase_NamedVector_Base_Wrench_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_Wrench_elements) {    .nCount = 1,    .arr = 
    {
        {
            .force = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .torque = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_Wrench_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_Wrench_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_Wrench_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Wrench_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Waypoint_Initialize(asn1SccBase_Waypoint* pVal)
{
    *pVal = (asn1SccBase_Waypoint) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Waypoint_IsConstraintValid(const asn1SccBase_Waypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose_m_Initialize(asn1SccBase_Pose_m* pVal)
{
    *pVal = (asn1SccBase_Pose_m) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_Pose_m_IsConstraintValid(const asn1SccBase_Pose_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TransformWithCovariance_m_Initialize(asn1SccBase_TransformWithCovariance_m* pVal)
{
    *pVal = (asn1SccBase_TransformWithCovariance_m) {
    .translation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TransformWithCovariance_m_IsConstraintValid(const asn1SccBase_TransformWithCovariance_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TwistWithCovariance_m_Initialize(asn1SccBase_TwistWithCovariance_m* pVal)
{
    *pVal = (asn1SccBase_TwistWithCovariance_m) {
    .vel = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .rot = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TwistWithCovariance_m_IsConstraintValid(const asn1SccBase_TwistWithCovariance_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->vel, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rot, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Waypoint_m_Initialize(asn1SccBase_Waypoint_m* pVal)
{
    *pVal = (asn1SccBase_Waypoint_m) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Waypoint_m_IsConstraintValid(const asn1SccBase_Waypoint_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint) {    .nCount = 1,    .arr = 
    {
        {
            .position = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .heading = 0.00000000000000000000E+000,
            .tol_position = 0.00000000000000000000E+000,
            .tol_heading = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_Waypoint);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Waypoint_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Wrench_m_Initialize(asn1SccBase_Wrench_m* pVal)
{
    *pVal = (asn1SccBase_Wrench_m) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Wrench_m_IsConstraintValid(const asn1SccBase_Wrench_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench) {    .nCount = 1,    .arr = 
    {
        {
            .force = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .torque = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_Wrench);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Wrench_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_m_points_Initialize(asn1SccBase_samples_Pointcloud_m_points* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_m_points) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_m_points_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_m_points);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_m_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_points_Initialize(asn1SccBase_samples_Pointcloud_points* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_points) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_points_IsConstraintValid(const asn1SccBase_samples_Pointcloud_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_points);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix2d_data_Initialize(asn1SccWrappers_Matrix2d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix2d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix2d_data_IsConstraintValid(const asn1SccWrappers_Matrix2d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix2d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix2d_Initialize(asn1SccWrappers_Matrix2d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix2d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix2d_IsConstraintValid(const asn1SccWrappers_Matrix2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix2d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector2d_data_Initialize(asn1SccWrappers_Vector2d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector2d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector2d_data_IsConstraintValid(const asn1SccWrappers_Vector2d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector2d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector2d_Initialize(asn1SccWrappers_Vector2d* pVal)
{
    *pVal = (asn1SccWrappers_Vector2d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector2d_IsConstraintValid(const asn1SccWrappers_Vector2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector2d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose2D_Initialize(asn1SccBase_Pose2D* pVal)
{
    *pVal = (asn1SccBase_Pose2D) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Pose2D_IsConstraintValid(const asn1SccBase_Pose2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector2d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose2D_m_Initialize(asn1SccBase_Pose2D_m* pVal)
{
    *pVal = (asn1SccBase_Pose2D_m) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Pose2D_m_IsConstraintValid(const asn1SccBase_Pose2D_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector2d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_AngleAxisd_axis_Initialize(asn1SccWrappers_AngleAxisd_axis* pVal)
{
    *pVal = (asn1SccWrappers_AngleAxisd_axis) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_AngleAxisd_axis_IsConstraintValid(const asn1SccWrappers_AngleAxisd_axis* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_AngleAxisd_axis;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_AngleAxisd_Initialize(asn1SccWrappers_AngleAxisd* pVal)
{
    *pVal = (asn1SccWrappers_AngleAxisd) {
    .angle = 0.00000000000000000000E+000,
    .axis = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_AngleAxisd_IsConstraintValid(const asn1SccWrappers_AngleAxisd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->angle, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_AngleAxisd_axis_IsConstraintValid(&pVal->axis, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_horizontal_interval_Initialize(asn1SccBase_samples_DepthMap_horizontal_interval* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_horizontal_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_horizontal_interval_IsConstraintValid(const asn1SccBase_samples_DepthMap_horizontal_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_horizontal_interval);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_horizontal_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_vertical_interval_Initialize(asn1SccBase_samples_DepthMap_vertical_interval* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_vertical_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_vertical_interval_IsConstraintValid(const asn1SccBase_samples_DepthMap_vertical_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_vertical_interval);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_vertical_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{
    *pVal = (asn1SccT_Float) 0.00000000000000000000E+000;
}
#endif

 
flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-3.40282346600000020000E+038 <= *pVal && *pVal <= 3.40282346600000020000E+038);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Float;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointState_Initialize(asn1SccBase_JointState* pVal)
{
    *pVal = (asn1SccBase_JointState) {
    .position = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .effort = 0.00000000000000000000E+000,
    .raw = 0.00000000000000000000E+000,
    .acceleration = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_JointState_IsConstraintValid(const asn1SccBase_JointState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->speed, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Float_IsConstraintValid(&pVal->effort, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->raw, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTrajectory_Initialize(asn1SccBase_JointTrajectory* pVal)
{
    *pVal = (asn1SccBase_JointTrajectory) {    .nCount = 1,    .arr = 
    {
        {
            .position = 0.00000000000000000000E+000,
            .speed = 0.00000000000000000000E+000,
            .effort = 0.00000000000000000000E+000,
            .raw = 0.00000000000000000000E+000,
            .acceleration = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTrajectory_IsConstraintValid(const asn1SccBase_JointTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTrajectory);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTrajectory;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointState_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTrajectory_elements_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTrajectory_elements) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }        
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTrajectory_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTrajectory_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTrajectory_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_elements_Initialize(asn1SccBase_JointsTrajectory_elements* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory_elements) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }        
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_elements_IsConstraintValid(const asn1SccBase_JointsTrajectory_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointsTrajectory_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointsTrajectory_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimitRange_Initialize(asn1SccBase_JointLimitRange* pVal)
{
    *pVal = (asn1SccBase_JointLimitRange) {
    .min = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    },
    .max = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_JointLimitRange_IsConstraintValid(const asn1SccBase_JointLimitRange* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointState_IsConstraintValid(&pVal->min, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointState_IsConstraintValid(&pVal->max, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointLimitRange_elements_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointLimitRange_elements) {    .nCount = 1,    .arr = 
    {
        {
            .min = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            },
            .max = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointLimitRange_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointLimitRange_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointLimitRange_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointLimitRange_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimits_elements_Initialize(asn1SccBase_JointLimits_elements* pVal)
{
    *pVal = (asn1SccBase_JointLimits_elements) {    .nCount = 1,    .arr = 
    {
        {
            .min = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            },
            .max = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointLimits_elements_IsConstraintValid(const asn1SccBase_JointLimits_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointLimits_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointLimits_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointLimitRange_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pressure_Initialize(asn1SccBase_Pressure* pVal)
{
    *pVal = (asn1SccBase_Pressure) {
    .pascal = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Pressure_IsConstraintValid(const asn1SccBase_Pressure* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Float_IsConstraintValid(&pVal->pascal, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_bins_Initialize(asn1SccBase_samples_Sonar_bins* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar_bins) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_bins_IsConstraintValid(const asn1SccBase_samples_Sonar_bins* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Sonar_bins);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Sonar_bins;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LaserScan_remission_Initialize(asn1SccBase_samples_LaserScan_remission* pVal)
{
    *pVal = (asn1SccBase_samples_LaserScan_remission) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_LaserScan_remission_IsConstraintValid(const asn1SccBase_samples_LaserScan_remission* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_LaserScan_remission);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_LaserScan_remission;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DistanceImage_data_Initialize(asn1SccBase_samples_DistanceImage_data* pVal)
{
    *pVal = (asn1SccBase_samples_DistanceImage_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DistanceImage_data_IsConstraintValid(const asn1SccBase_samples_DistanceImage_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DistanceImage_data);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DistanceImage_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_remissions_Initialize(asn1SccBase_samples_DepthMap_remissions* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_remissions) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_remissions_IsConstraintValid(const asn1SccBase_samples_DepthMap_remissions* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_remissions);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_remissions;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_distances_Initialize(asn1SccBase_samples_DepthMap_distances* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_distances) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_distances_IsConstraintValid(const asn1SccBase_samples_DepthMap_distances* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_distances);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_distances;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int16_Initialize(asn1SccT_Int16* pVal)
{
    *pVal = (asn1SccT_Int16) -32768;
}
#endif

 
flag asn1SccT_Int16_IsConstraintValid(const asn1SccT_Int16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-32768 <= *pVal && *pVal <= 32767);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int16;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal)
{
    *pVal = (asn1SccT_UInt16) 0;
}
#endif

 
flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 65535);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt16;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_size_t_Initialize(asn1SccBase_samples_frame_frame_size_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_size_t) {
    .width = 0,
    .height = 0
};
}
#endif

 
flag asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_size_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_UInt16_IsConstraintValid(&pVal->width, pErrCode);
	if (ret) {
	    ret = asn1SccT_UInt16_IsConstraintValid(&pVal->height, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal)
{
    *pVal = (asn1SccT_UInt64) 0;
}
#endif

 
flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt64;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int64_Initialize(asn1SccT_Int64* pVal)
{
    *pVal = (asn1SccT_Int64) -9223372036854775807LL;
}
#endif

 
flag asn1SccT_Int64_IsConstraintValid(const asn1SccT_Int64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-9223372036854775807LL <= *pVal && *pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int64;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Time_Initialize(asn1SccBase_Time* pVal)
{
    *pVal = (asn1SccBase_Time) {
    .microseconds = -9223372036854775807LL
};
}
#endif

 
flag asn1SccBase_Time_IsConstraintValid(const asn1SccBase_Time* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int64_IsConstraintValid(&pVal->microseconds, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TimeStamped_Base_commands_Motion2D_Initialize(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal)
{
    *pVal = (asn1SccBase_TimeStamped_Base_commands_Motion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000,
    .heading = {
        .rad = 0.00000000000000000000E+000
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->heading, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_LinearAngular6DCommand_Initialize(asn1SccBase_LinearAngular6DCommand* pVal)
{
    *pVal = (asn1SccBase_LinearAngular6DCommand) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .linear = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_LinearAngular6DCommand_IsConstraintValid(const asn1SccBase_LinearAngular6DCommand* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->linear, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_BodyState_Initialize(asn1SccBase_samples_BodyState* pVal)
{
    *pVal = (asn1SccBase_samples_BodyState) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .pose = {
        .translation = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .orientation = {
            .im = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            },
            .re = 0.00000000000000000000E+000
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    },
    .velocity = {
        .vel = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .rot = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_BodyState_IsConstraintValid(const asn1SccBase_samples_BodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_TransformWithCovariance_IsConstraintValid(&pVal->pose, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_TwistWithCovariance_IsConstraintValid(&pVal->velocity, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_IMUSensors_Initialize(asn1SccBase_samples_IMUSensors* pVal)
{
    *pVal = (asn1SccBase_samples_IMUSensors) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acc = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .gyro = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .mag = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_IMUSensors_IsConstraintValid(const asn1SccBase_samples_IMUSensors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acc, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->gyro, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->mag, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Motion2D_Initialize(asn1SccBase_samples_Motion2D* pVal)
{
    *pVal = (asn1SccBase_samples_Motion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000,
    .heading = {
        .rad = 0.00000000000000000000E+000
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Motion2D_IsConstraintValid(const asn1SccBase_samples_Motion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->heading, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pressure_Initialize(asn1SccBase_samples_Pressure* pVal)
{
    *pVal = (asn1SccBase_samples_Pressure) {
    .pascal = 0.00000000000000000000E+000,
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Pressure_IsConstraintValid(const asn1SccBase_samples_Pressure* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Float_IsConstraintValid(&pVal->pascal, pErrCode);
	if (ret) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyAcceleration_Initialize(asn1SccBase_samples_RigidBodyAcceleration* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyAcceleration) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acceleration, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_acceleration, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_acceleration, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrench_Initialize(asn1SccBase_samples_Wrench* pVal)
{
    *pVal = (asn1SccBase_samples_Wrench) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrench_IsConstraintValid(const asn1SccBase_samples_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DistanceImage_Initialize(asn1SccBase_samples_DistanceImage* pVal)
{
    *pVal = (asn1SccBase_samples_DistanceImage) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .width = 0,
    .height = 0,
    .scale_x = 0.00000000000000000000E+000,
    .scale_y = 0.00000000000000000000E+000,
    .center_x = 0.00000000000000000000E+000,
    .center_y = 0.00000000000000000000E+000,
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_DistanceImage_IsConstraintValid(const asn1SccBase_samples_DistanceImage* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_UInt16_IsConstraintValid(&pVal->width, pErrCode);
	    if (ret) {
	        ret = asn1SccT_UInt16_IsConstraintValid(&pVal->height, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->scale_x, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->scale_y, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->center_x, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_Float_IsConstraintValid(&pVal->center_y, pErrCode);
	                        if (ret) {
	                            ret = asn1SccBase_samples_DistanceImage_data_IsConstraintValid(&pVal->data, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_Initialize(asn1SccBase_samples_Pointcloud* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .points = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    },
    .colors = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_IsConstraintValid(const asn1SccBase_samples_Pointcloud* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Pointcloud_points_IsConstraintValid(&pVal->points, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_Pointcloud_colors_IsConstraintValid(&pVal->colors, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_LinearAngular6DCommand_m_Initialize(asn1SccBase_commands_LinearAngular6DCommand_m* pVal)
{
    *pVal = (asn1SccBase_commands_LinearAngular6DCommand_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .linear = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(const asn1SccBase_commands_LinearAngular6DCommand_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->linear, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_BodyState_m_Initialize(asn1SccBase_samples_BodyState_m* pVal)
{
    *pVal = (asn1SccBase_samples_BodyState_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .pose = {
        .translation = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .orientation = {
            .im = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            },
            .re = 0.00000000000000000000E+000
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    },
    .velocity = {
        .vel = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .rot = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_BodyState_m_IsConstraintValid(const asn1SccBase_samples_BodyState_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_TransformWithCovariance_m_IsConstraintValid(&pVal->pose, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_TwistWithCovariance_m_IsConstraintValid(&pVal->velocity, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_IMUSensors_m_Initialize(asn1SccBase_samples_IMUSensors_m* pVal)
{
    *pVal = (asn1SccBase_samples_IMUSensors_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acc = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .gyro = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .mag = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_IMUSensors_m_IsConstraintValid(const asn1SccBase_samples_IMUSensors_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acc, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->gyro, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->mag, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyAcceleration_m_Initialize(asn1SccBase_samples_RigidBodyAcceleration_m* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyAcceleration_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acceleration, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_acceleration, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_acceleration, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrench_m_Initialize(asn1SccBase_samples_Wrench_m* pVal)
{
    *pVal = (asn1SccBase_samples_Wrench_m) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrench_m_IsConstraintValid(const asn1SccBase_samples_Wrench_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_m_Initialize(asn1SccBase_samples_Pointcloud_m* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .points = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    },
    .colors = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_m_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Pointcloud_m_points_IsConstraintValid(&pVal->points, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_Pointcloud_m_colors_IsConstraintValid(&pVal->colors, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarScan_time_beams_Initialize(asn1SccBase_samples_SonarScan_time_beams* pVal)
{
    *pVal = (asn1SccBase_samples_SonarScan_time_beams) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarScan_time_beams_IsConstraintValid(const asn1SccBase_samples_SonarScan_time_beams* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_SonarScan_time_beams);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_SonarScan_time_beams;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_timestamps_Initialize(asn1SccBase_samples_Sonar_timestamps* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_timestamps_IsConstraintValid(const asn1SccBase_samples_Sonar_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Sonar_timestamps);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Sonar_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_timestamps_Initialize(asn1SccBase_samples_DepthMap_timestamps* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_timestamps_IsConstraintValid(const asn1SccBase_samples_DepthMap_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_timestamps);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_times_t_Initialize(asn1SccBase_JointsTrajectory_times_t* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory_times_t) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_times_t_IsConstraintValid(const asn1SccBase_JointsTrajectory_times_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointsTrajectory_times_t);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointsTrajectory_times_t;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_String_Initialize(asn1SccT_String* pVal)
{
    *pVal = (asn1SccT_String) {0,
    {
    }
};
}
#endif

 
flag asn1SccT_String_IsConstraintValid(const asn1SccT_String* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)numT_String);
	*pErrCode = ret ? 0 : ERR_asn1SccT_String;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransform_Initialize(asn1SccBase_JointTransform* pVal)
{
    *pVal = (asn1SccBase_JointTransform) {
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .rotationaxis = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransform_IsConstraintValid(const asn1SccBase_JointTransform* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rotationaxis, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTransform_elements_Initialize(asn1SccBase_NamedVector_Base_JointTransform_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTransform_elements) {    .nCount = 1,    .arr = 
    {
        {
            .sourceframe = {0,
                {
                }
            },
            .targetframe = {0,
                {
                }
            },
            .rotationaxis = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTransform_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTransform_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTransform_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTransform_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_elements_Initialize(asn1SccBase_JointTransformVector_elements* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_elements) {    .nCount = 1,    .arr = 
    {
        {
            .sourceframe = {0,
                {
                }
            },
            .targetframe = {0,
                {
                }
            },
            .rotationaxis = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_elements_IsConstraintValid(const asn1SccBase_JointTransformVector_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTransformVector_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTransformVector_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTransform_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyState_Initialize(asn1SccBase_samples_RigidBodyState* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyState) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov_orientation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyState_IsConstraintValid(const asn1SccBase_samples_RigidBodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	    if (ret) {
	        ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_position, pErrCode);
	                if (ret) {
	                    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	                    if (ret) {
	                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_orientation, pErrCode);
	                        if (ret) {
	                            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->velocity, pErrCode);
	                            if (ret) {
	                                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_velocity, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_velocity, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_velocity, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_attrib_t_Initialize(asn1SccBase_samples_frame_frame_attrib_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_attrib_t) {
    .data = {0,
        {
        }
    },
    .name_t = {0,
        {
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_attrib_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->data, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->name_t, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_Frame_attributes_Initialize(asn1SccBase_samples_frame_Frame_attributes* pVal)
{
    *pVal = (asn1SccBase_samples_frame_Frame_attributes) {    .nCount = 1,    .arr = 
    {
        {
            .data = {0,
                {
                }
            },
            .name_t = {0,
                {
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_frame_Frame_attributes_IsConstraintValid(const asn1SccBase_samples_frame_Frame_attributes* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_frame_Frame_attributes);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_Frame_attributes;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransform_m_Initialize(asn1SccBase_JointTransform_m* pVal)
{
    *pVal = (asn1SccBase_JointTransform_m) {
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .rotationaxis = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransform_m_IsConstraintValid(const asn1SccBase_JointTransform_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rotationaxis, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform) {    .nCount = 1,    .arr = 
    {
        {
            .sourceframe = {0,
                {
                }
            },
            .targetframe = {0,
                {
                }
            },
            .rotationaxis = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_JointTransform);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTransform_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyState_m_Initialize(asn1SccBase_samples_RigidBodyState_m* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyState_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov_orientation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyState_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	    if (ret) {
	        ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_position, pErrCode);
	                if (ret) {
	                    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	                    if (ret) {
	                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_orientation, pErrCode);
	                        if (ret) {
	                            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->velocity, pErrCode);
	                            if (ret) {
	                                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_velocity, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_velocity, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_velocity, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_m_names_Initialize(asn1SccBase_samples_Wrenches_m_names* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_m_names_IsConstraintValid(const asn1SccBase_samples_Wrenches_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Wrenches_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Wrenches_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_m_Initialize(asn1SccBase_samples_Wrenches_m* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_m_IsConstraintValid(const asn1SccBase_samples_Wrenches_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_samples_Wrenches_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_Wrench_m_names_Initialize(asn1SccBase_NamedVector_base_Wrench_m_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_Wrench_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_Wrench_m_names_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_base_Wrench_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_base_Wrench_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_Wrench_m_Initialize(asn1SccBase_NamedVector_base_Wrench_m* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_Wrench_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_base_Wrench_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_JointTransform_m_names_Initialize(asn1SccBase_NamedVector_base_JointTransform_m_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_JointTransform_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_JointTransform_m_names_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_base_JointTransform_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_base_JointTransform_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_JointTransform_m_Initialize(asn1SccBase_NamedVector_base_JointTransform_m* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_JointTransform_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_base_JointTransform_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_m_names_Initialize(asn1SccBase_JointTransformVector_m_names* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_m_names_IsConstraintValid(const asn1SccBase_JointTransformVector_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTransformVector_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTransformVector_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_m_Initialize(asn1SccBase_JointTransformVector_m* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_m_IsConstraintValid(const asn1SccBase_JointTransformVector_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointTransformVector_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTransform_names_Initialize(asn1SccBase_NamedVector_Base_JointTransform_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTransform_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTransform_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTransform_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTransform_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTransform_Initialize(asn1SccBase_NamedVector_Base_JointTransform* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTransform) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointTransform_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_JointTransform_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_names_Initialize(asn1SccBase_JointTransformVector_names* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_names_IsConstraintValid(const asn1SccBase_JointTransformVector_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTransformVector_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTransformVector_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_Initialize(asn1SccBase_JointTransformVector* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_IsConstraintValid(const asn1SccBase_JointTransformVector* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointTransformVector_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointTransformVector_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_names_Initialize(asn1SccBase_samples_Wrenches_names* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_names_IsConstraintValid(const asn1SccBase_samples_Wrenches_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Wrenches_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Wrenches_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_Initialize(asn1SccBase_samples_Wrenches* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_IsConstraintValid(const asn1SccBase_samples_Wrenches* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_samples_Wrenches_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Wrenches_elements_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Joints_names_Initialize(asn1SccBase_commands_Joints_names* pVal)
{
    *pVal = (asn1SccBase_commands_Joints_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_commands_Joints_names_IsConstraintValid(const asn1SccBase_commands_Joints_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_commands_Joints_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_commands_Joints_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Joints_Initialize(asn1SccBase_commands_Joints* pVal)
{
    *pVal = (asn1SccBase_commands_Joints) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }        
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_commands_Joints_IsConstraintValid(const asn1SccBase_commands_Joints* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_commands_Joints_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTrajectory_names_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTrajectory_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTrajectory_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTrajectory_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTrajectory_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTrajectory_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTrajectory) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    {
                        .position = 0.00000000000000000000E+000,
                        .speed = 0.00000000000000000000E+000,
                        .effort = 0.00000000000000000000E+000,
                        .raw = 0.00000000000000000000E+000,
                        .acceleration = 0.00000000000000000000E+000
                    }        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointTrajectory_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_JointTrajectory_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_Wrench_names_Initialize(asn1SccBase_NamedVector_Base_Wrench_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_Wrench_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_Wrench_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_Wrench_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_Wrench_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_Wrench_Initialize(asn1SccBase_NamedVector_Base_Wrench* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_Wrench) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_Wrench_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_Wrench_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointState_names_Initialize(asn1SccBase_NamedVector_Base_JointState_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointState_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointState_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointState_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointState_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointState_Initialize(asn1SccBase_NamedVector_Base_JointState* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointState) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointState_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointLimitRange_names_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointLimitRange_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointLimitRange_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointLimitRange_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointLimitRange_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointLimitRange_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointLimitRange) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .min = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                },
                .max = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointLimitRange_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_JointLimitRange_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_names_Initialize(asn1SccBase_JointsTrajectory_names* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_names_IsConstraintValid(const asn1SccBase_JointsTrajectory_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointsTrajectory_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointsTrajectory_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_Initialize(asn1SccBase_JointsTrajectory* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    {
                        .position = 0.00000000000000000000E+000,
                        .speed = 0.00000000000000000000E+000,
                        .effort = 0.00000000000000000000E+000,
                        .raw = 0.00000000000000000000E+000,
                        .acceleration = 0.00000000000000000000E+000
                    }        
                }
            }        
        }
    },
    .times_t = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_IsConstraintValid(const asn1SccBase_JointsTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointsTrajectory_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointsTrajectory_elements_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_JointsTrajectory_times_t_IsConstraintValid(&pVal->times_t, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimits_names_Initialize(asn1SccBase_JointLimits_names* pVal)
{
    *pVal = (asn1SccBase_JointLimits_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointLimits_names_IsConstraintValid(const asn1SccBase_JointLimits_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointLimits_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointLimits_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimits_Initialize(asn1SccBase_JointLimits* pVal)
{
    *pVal = (asn1SccBase_JointLimits) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .min = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                },
                .max = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointLimits_IsConstraintValid(const asn1SccBase_JointLimits* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointLimits_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointLimits_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
    *pVal = (asn1SccT_Int32) -2147483648LL;
}
#endif

 
flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int32;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_MatrixXd_Initialize(asn1SccWrappers_MatrixXd* pVal)
{
    *pVal = (asn1SccWrappers_MatrixXd) {
    .rows = -2147483648LL,
    .cols = -2147483648LL,
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_MatrixXd_IsConstraintValid(const asn1SccWrappers_MatrixXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int32_IsConstraintValid(&pVal->rows, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->cols, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_MatrixXd_data_IsConstraintValid(&pVal->data, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_Spline_Initialize(asn1SccWrappers_geometry_Spline* pVal)
{
    *pVal = (asn1SccWrappers_geometry_Spline) {
    .geometric_resolution = 0.00000000000000000000E+000,
    .dimension = -2147483648LL,
    .curve_order = -2147483648LL,
    .kind = asn1Sccdegenerate,
    .knots = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertices = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_geometry_Spline_IsConstraintValid(const asn1SccWrappers_geometry_Spline* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->geometric_resolution, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->dimension, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Int32_IsConstraintValid(&pVal->curve_order, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_geometry_SplineType_IsConstraintValid(&pVal->kind, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_geometry_Spline_knots_IsConstraintValid(&pVal->knots, pErrCode);
	                if (ret) {
	                    ret = asn1SccWrappers_geometry_Spline_vertices_IsConstraintValid(&pVal->vertices, pErrCode);
	                
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Trajectory_Initialize(asn1SccBase_Trajectory* pVal)
{
    *pVal = (asn1SccBase_Trajectory) {
    .speed = 0.00000000000000000000E+000,
    .spline = {
        .geometric_resolution = 0.00000000000000000000E+000,
        .dimension = -2147483648LL,
        .curve_order = -2147483648LL,
        .kind = asn1Sccdegenerate,
        .knots = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .vertices = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Trajectory_IsConstraintValid(const asn1SccBase_Trajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_geometry_Spline_IsConstraintValid(&pVal->spline, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Trajectory_m_Initialize(asn1SccBase_Trajectory_m* pVal)
{
    *pVal = (asn1SccBase_Trajectory_m) {
    .speed = 0.00000000000000000000E+000,
    .spline = {
        .geometric_resolution = 0.00000000000000000000E+000,
        .dimension = -2147483648LL,
        .curve_order = -2147483648LL,
        .kind = asn1Sccdegenerate,
        .knots = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .vertices = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Trajectory_m_IsConstraintValid(const asn1SccBase_Trajectory_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_geometry_Spline_IsConstraintValid(&pVal->spline, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory) {    .nCount = 1,    .arr = 
    {
        {
            .speed = 0.00000000000000000000E+000,
            .spline = {
                .geometric_resolution = 0.00000000000000000000E+000,
                .dimension = -2147483648LL,
                .curve_order = -2147483648LL,
                .kind = asn1Sccdegenerate,
                .knots = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                },
                .vertices = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_Trajectory);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Trajectory_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
    *pVal = (asn1SccT_UInt32) 0;
}
#endif

 
flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt32;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_Initialize(asn1SccBase_samples_DepthMap* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    },
    .vertical_projection = asn1Sccplanar,
    .horizontal_projection = asn1Sccplanar,
    .vertical_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .horizontal_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertical_size = 0,
    .horizontal_size = 0,
    .distances = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .remissions = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_IsConstraintValid(const asn1SccBase_samples_DepthMap* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_DepthMap_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(&pVal->vertical_projection, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(&pVal->horizontal_projection, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_samples_DepthMap_vertical_interval_IsConstraintValid(&pVal->vertical_interval, pErrCode);
	                if (ret) {
	                    ret = asn1SccBase_samples_DepthMap_horizontal_interval_IsConstraintValid(&pVal->horizontal_interval, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->vertical_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->horizontal_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccBase_samples_DepthMap_distances_IsConstraintValid(&pVal->distances, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_samples_DepthMap_remissions_IsConstraintValid(&pVal->remissions, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_Initialize(asn1SccBase_samples_Sonar* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    },
    .bin_duration = {
        .microseconds = -9223372036854775807LL
    },
    .beam_width = {
        .rad = 0.00000000000000000000E+000
    },
    .beam_height = {
        .rad = 0.00000000000000000000E+000
    },
    .bearings = {    .nCount = 1,    .arr = 
        {
            {
                .rad = 0.00000000000000000000E+000
            }        
        }
    },
    .speed_of_sound = 0.00000000000000000000E+000,
    .bin_count = 0,
    .beam_count = 0,
    .bins = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_IsConstraintValid(const asn1SccBase_samples_Sonar* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Sonar_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->bin_duration, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beam_width, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beam_height, pErrCode);
	                if (ret) {
	                    ret = asn1SccBase_samples_Sonar_bearings_IsConstraintValid(&pVal->bearings, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->bin_count, pErrCode);
	                            if (ret) {
	                                ret = asn1SccT_UInt32_IsConstraintValid(&pVal->beam_count, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_samples_Sonar_bins_IsConstraintValid(&pVal->bins, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LaserScan_ranges_Initialize(asn1SccBase_samples_LaserScan_ranges* pVal)
{
    *pVal = (asn1SccBase_samples_LaserScan_ranges) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccBase_samples_LaserScan_ranges_IsConstraintValid(const asn1SccBase_samples_LaserScan_ranges* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_LaserScan_ranges);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_LaserScan_ranges;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LaserScan_Initialize(asn1SccBase_samples_LaserScan* pVal)
{
    *pVal = (asn1SccBase_samples_LaserScan) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .start_angle = 0.00000000000000000000E+000,
    .angular_resolution = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .ranges = {    .nCount = 1,    .arr = 
        {
            0        
        }
    },
    .minrange = 0,
    .maxrange = 0,
    .remission = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_LaserScan_IsConstraintValid(const asn1SccBase_samples_LaserScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->start_angle, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_samples_LaserScan_ranges_IsConstraintValid(&pVal->ranges, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->minrange, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->maxrange, pErrCode);
	                        if (ret) {
	                            ret = asn1SccBase_samples_LaserScan_remission_IsConstraintValid(&pVal->remission, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDummy_T_Initialize(asn1SccDummy_T* pVal)
{
    *pVal = (asn1SccDummy_T) 0;
}
#endif

 
flag asn1SccDummy_T_IsConstraintValid(const asn1SccDummy_T* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDummy2_T_Initialize(asn1SccDummy2_T* pVal)
{
    *pVal = (asn1SccDummy2_T) 0;
}
#endif

 
flag asn1SccDummy2_T_IsConstraintValid(const asn1SccDummy2_T* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccDummy_T_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDummy3T_Initialize(asn1SccDummy3T* pVal)
{
    *pVal = (asn1SccDummy3T) 0;
}
#endif

 
flag asn1SccDummy3T_IsConstraintValid(const asn1SccDummy3T* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccDummy_T_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
    *pVal = (asn1SccT_Int8) -128;
}
#endif

 
flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-128 <= *pVal && *pVal <= 127);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int8;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
    *pVal = (asn1SccT_UInt8) 0;
}
#endif

 
flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt8;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_Frame_image_Initialize(asn1SccBase_samples_frame_Frame_image* pVal)
{
    *pVal = (asn1SccBase_samples_frame_Frame_image) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccBase_samples_frame_Frame_image_IsConstraintValid(const asn1SccBase_samples_frame_Frame_image* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_frame_Frame_image);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_Frame_image;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_Frame_Initialize(asn1SccBase_samples_frame_Frame* pVal)
{
    *pVal = (asn1SccBase_samples_frame_Frame) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .received_time = {
        .microseconds = -9223372036854775807LL
    },
    .image = {    .nCount = 1,    .arr = 
        {
            0        
        }
    },
    .attributes = {    .nCount = 1,    .arr = 
        {
            {
                .data = {0,
                    {
                    }
                },
                .name_t = {0,
                    {
                    }
                }
            }        
        }
    },
    .size_t = {
        .width = 0,
        .height = 0
    },
    .data_depth = 0,
    .pixel_size = 0,
    .row_size = 0,
    .frame_mode = asn1Scccompressed_modes,
    .frame_status = asn1Sccstatus_empty
};
}
#endif

 
flag asn1SccBase_samples_frame_Frame_IsConstraintValid(const asn1SccBase_samples_frame_Frame* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->received_time, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_frame_Frame_image_IsConstraintValid(&pVal->image, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_samples_frame_Frame_attributes_IsConstraintValid(&pVal->attributes, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(&pVal->size_t, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->data_depth, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->pixel_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->row_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(&pVal->frame_mode, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(&pVal->frame_status, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_FramePair_Initialize(asn1SccBase_samples_frame_FramePair* pVal)
{
    *pVal = (asn1SccBase_samples_frame_FramePair) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .first = {
        .time = {
            .microseconds = -9223372036854775807LL
        },
        .received_time = {
            .microseconds = -9223372036854775807LL
        },
        .image = {    .nCount = 1,    .arr = 
            {
                0        
            }
        },
        .attributes = {    .nCount = 1,    .arr = 
            {
                {
                    .data = {0,
                        {
                        }
                    },
                    .name_t = {0,
                        {
                        }
                    }
                }        
            }
        },
        .size_t = {
            .width = 0,
            .height = 0
        },
        .data_depth = 0,
        .pixel_size = 0,
        .row_size = 0,
        .frame_mode = asn1Scccompressed_modes,
        .frame_status = asn1Sccstatus_empty
    },
    .second = {
        .time = {
            .microseconds = -9223372036854775807LL
        },
        .received_time = {
            .microseconds = -9223372036854775807LL
        },
        .image = {    .nCount = 1,    .arr = 
            {
                0        
            }
        },
        .attributes = {    .nCount = 1,    .arr = 
            {
                {
                    .data = {0,
                        {
                        }
                    },
                    .name_t = {0,
                        {
                        }
                    }
                }        
            }
        },
        .size_t = {
            .width = 0,
            .height = 0
        },
        .data_depth = 0,
        .pixel_size = 0,
        .row_size = 0,
        .frame_mode = asn1Scccompressed_modes,
        .frame_status = asn1Sccstatus_empty
    },
    .id = 0
};
}
#endif

 
flag asn1SccBase_samples_frame_FramePair_IsConstraintValid(const asn1SccBase_samples_frame_FramePair* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_frame_Frame_IsConstraintValid(&pVal->first, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_frame_Frame_IsConstraintValid(&pVal->second, pErrCode);
	        if (ret) {
	            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->id, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarScan_data_Initialize(asn1SccBase_samples_SonarScan_data* pVal)
{
    *pVal = (asn1SccBase_samples_SonarScan_data) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarScan_data_IsConstraintValid(const asn1SccBase_samples_SonarScan_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_SonarScan_data);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_SonarScan_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarBeam_beam_Initialize(asn1SccBase_samples_SonarBeam_beam* pVal)
{
    *pVal = (asn1SccBase_samples_SonarBeam_beam) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarBeam_beam_IsConstraintValid(const asn1SccBase_samples_SonarBeam_beam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_SonarBeam_beam);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_SonarBeam_beam;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarBeam_Initialize(asn1SccBase_samples_SonarBeam* pVal)
{
    *pVal = (asn1SccBase_samples_SonarBeam) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = 0.00000000000000000000E+000,
    .beamwidth_vertical = 0.00000000000000000000E+000,
    .beam = {    .nCount = 1,    .arr = 
        {
            0        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarBeam_IsConstraintValid(const asn1SccBase_samples_SonarBeam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->bearing, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                    if (ret) {
	                        ret = asn1SccBase_samples_SonarBeam_beam_IsConstraintValid(&pVal->beam, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
    *pVal = (asn1SccT_Boolean) FALSE;
}
#endif

 
flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarScan_Initialize(asn1SccBase_samples_SonarScan* pVal)
{
    *pVal = (asn1SccBase_samples_SonarScan) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .data = {    .nCount = 1,    .arr = 
        {
            0        
        }
    },
    .time_beams = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    },
    .number_of_beams = 0,
    .number_of_bins = 0,
    .start_bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .angular_resolution = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = {
        .rad = 0.00000000000000000000E+000
    },
    .beamwidth_vertical = {
        .rad = 0.00000000000000000000E+000
    },
    .memory_layout_column = FALSE,
    .polar_coordinates = FALSE
};
}
#endif

 
flag asn1SccBase_samples_SonarScan_IsConstraintValid(const asn1SccBase_samples_SonarScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_SonarScan_data_IsConstraintValid(&pVal->data, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_SonarScan_time_beams_IsConstraintValid(&pVal->time_beams, pErrCode);
	        if (ret) {
	            ret = asn1SccT_UInt16_IsConstraintValid(&pVal->number_of_beams, pErrCode);
	            if (ret) {
	                ret = asn1SccT_UInt16_IsConstraintValid(&pVal->number_of_bins, pErrCode);
	                if (ret) {
	                    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->start_bearing, pErrCode);
	                    if (ret) {
	                        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	                            if (ret) {
	                                ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                                        if (ret) {
	                                            ret = asn1SccT_Boolean_IsConstraintValid(&pVal->memory_layout_column, pErrCode);
	                                            if (ret) {
	                                                ret = asn1SccT_Boolean_IsConstraintValid(&pVal->polar_coordinates, pErrCode);
	                                            
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVizkit3D_FilePath_Initialize(asn1SccVizkit3D_FilePath pVal)
{
    static asn1SccVizkit3D_FilePath ret = 
        "";
    strcpy(pVal, ret);
}
#endif

 
flag asn1SccVizkit3D_FilePath_IsConstraintValid(const asn1SccVizkit3D_FilePath pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= strlen(pVal) && strlen(pVal) <= (int)vizkit3d_PathMaxSize);
	*pErrCode = ret ? 0 : ERR_asn1SccVizkit3D_FilePath;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVizkit3D_PluginLabel_Initialize(asn1SccVizkit3D_PluginLabel pVal)
{
    static asn1SccVizkit3D_PluginLabel ret = 
        " ";
    strcpy(pVal, ret);
}
#endif

 
flag asn1SccVizkit3D_PluginLabel_IsConstraintValid(const asn1SccVizkit3D_PluginLabel pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= strlen(pVal) && strlen(pVal) <= (int)vizkit3d_LabelMaxSize);
	*pErrCode = ret ? 0 : ERR_asn1SccVizkit3D_PluginLabel;

	return ret;
}

const asn1SccT_UInt32 numT_String = 200;

const asn1SccT_UInt32 numBase_JointTrajectory = 200;

const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform = 200;

const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint = 200;

const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench = 200;

const asn1SccT_UInt32 numStd_vector_Wrappers_Vector4d = 200;

const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory = 200;

const asn1SccT_UInt32 numBase_JointLimits_names = 200;

const asn1SccT_UInt32 numBase_JointLimits_elements = 200;

const asn1SccT_UInt32 numBase_JointsTrajectory_names = 200;

const asn1SccT_UInt32 numBase_JointsTrajectory_elements = 200;

const asn1SccT_UInt32 numBase_JointsTrajectory_times_t = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointLimitRange_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointLimitRange_elements = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointState_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_Wrench_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_Wrench_elements = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointTrajectory_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointTrajectory_elements = 200;

const asn1SccT_UInt32 numBase_samples_DepthMap_timestamps = 200;

const asn1SccT_UInt32 numBase_samples_DepthMap_vertical_interval = 200;

const asn1SccT_UInt32 numBase_samples_DepthMap_horizontal_interval = 200;

const asn1SccT_UInt32 numBase_samples_DepthMap_distances = 200;

const asn1SccT_UInt32 numBase_samples_DepthMap_remissions = 200;

const asn1SccT_UInt32 numBase_samples_DistanceImage_data = 200;

const asn1SccT_UInt32 numBase_commands_Joints_names = 200;

const asn1SccT_UInt32 numBase_samples_LaserScan_ranges = 200;

const asn1SccT_UInt32 numBase_samples_LaserScan_remission = 200;

const asn1SccT_UInt32 numBase_samples_Pointcloud_points = 200;

const asn1SccT_UInt32 numBase_samples_Pointcloud_colors = 200;

const asn1SccT_UInt32 numBase_samples_Sonar_timestamps = 200;

const asn1SccT_UInt32 numBase_samples_Sonar_bearings = 200;

const asn1SccT_UInt32 numBase_samples_Sonar_bins = 200;

const asn1SccT_UInt32 numBase_samples_SonarBeam_beam = 200;

const asn1SccT_UInt32 numBase_samples_SonarScan_data = 200;

const asn1SccT_UInt32 numBase_samples_SonarScan_time_beams = 200;

const asn1SccT_UInt32 numBase_samples_Wrenches_names = 200;

const asn1SccT_UInt32 numBase_samples_Wrenches_elements = 200;

const asn1SccT_UInt32 numBase_JointTransformVector_names = 200;

const asn1SccT_UInt32 numBase_JointTransformVector_elements = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointTransform_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_Base_JointTransform_elements = 200;

const asn1SccT_UInt32 numBase_samples_frame_Frame_image = 200;

const asn1SccT_UInt32 numBase_samples_frame_Frame_attributes = 200;

const asn1SccT_UInt32 numWrappers_MatrixXd_data = 200;

const asn1SccT_UInt32 numWrappers_VectorXd_data = 200;

const asn1SccT_UInt32 numBase_JointTransformVector_m_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_base_JointTransform_m_names = 200;

const asn1SccT_UInt32 numBase_NamedVector_base_Wrench_m_names = 200;

const asn1SccT_UInt32 numBase_samples_Pointcloud_m_points = 200;

const asn1SccT_UInt32 numBase_samples_Pointcloud_m_colors = 200;

const asn1SccT_UInt32 numBase_samples_Wrenches_m_names = 200;

const asn1SccT_UInt32 numWrappers_geometry_Spline_knots = 200;

const asn1SccT_UInt32 numWrappers_geometry_Spline_vertices = 200;

const asn1SccT_UInt32 vizkit3d_PathMaxSize = 255;

const asn1SccT_UInt32 vizkit3d_LabelMaxSize = 31;
